<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<dict>
    <entry key="add_primary_key_to_header">
        <int>1</int>
    </entry>
    <entry key="blockstrategy">
        <dict>
            <entry key="mininterblockinterval">
                <int>1000</int>
            </entry>
            <entry key="name">
                <string>net.postchain.base.BaseBlockBuildingStrategy</string>
            </entry>
        </dict>
    </entry>
    <entry key="config_consensus_strategy">
        <string>HEADER_HASH</string>
    </entry>
    <entry key="configurationfactory">
        <string>net.postchain.gtx.GTXBlockchainConfigurationFactory</string>
    </entry>
    <entry key="gtx">
        <dict>
            <entry key="modules">
                <array>
                    <string>net.postchain.rell.module.RellPostchainModuleFactory</string>
                    <string>net.postchain.gtx.StandardOpsGTXModule</string>
                </array>
            </entry>
            <entry key="rell">
                <dict>
                    <entry key="compilerVersion">
                        <string>0.14.3</string>
                    </entry>
                    <entry key="moduleArgs">
                        <dict>
                            <entry key="lib.ft4.core.auth">
                                <dict>
                                    <entry key="evm_signatures_authorized_operations">
                                        <array>
                                            <string>register_user</string>
                                        </array>
                                    </entry>
                                </dict>
                            </entry>
                        </dict>
                    </entry>
                    <entry key="modules">
                        <array>
                            <string>main</string>
                        </array>
                    </entry>
                    <entry key="sources">
                        <dict>
                            <entry key="lib/ft4/accounts/module.rell">
                                <string>import ^.core.accounts.*;&#13;
import external: ^.external.accounts;&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/accounts/strategies/module.rell">
                                <string>import ^^.core.accounts.strategies.*;&#13;
import external: ^^.external.accounts.strategies;&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/accounts/strategies/open/module.rell">
                                <string>import ^^^.core.accounts.strategies.open.*;</string>
                            </entry>
                            <entry key="lib/ft4/auth/module.rell">
                                <string>import ^.core.auth.*;&#13;
import external: ^.external.auth;&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/core/accounts/auth_basic.rell">
                                <string>&#13;
struct single_sig_args {&#13;
    flags: set&lt;text&gt;;&#13;
    signer: byte_array;&#13;
}&#13;
&#13;
struct multi_sig_args {&#13;
    flags: set&lt;text&gt;;&#13;
    signatures_required: integer;&#13;
    signers: list&lt;byte_array&gt;;&#13;
}&#13;
&#13;
/*&#13;
 * Returns VALID if valid.&#13;
 */&#13;
function check_single_sig_auth(args: byte_array, signers: list&lt;byte_array&gt;, required_flags: list&lt;text&gt;): utils.validation_result {&#13;
    if(signers.size() &gt; 1) {&#13;
        return utils.invalid("Single sig Auth Descriptor must have only one signer.");&#13;
    }&#13;
    if (signers.size() &lt; 1) {&#13;
        return utils.invalid("Single sig Auth Descriptor's signer list is empty.");&#13;
    }&#13;
&#13;
    val ss_args = single_sig_args.from_bytes(args);&#13;
    if ( check_required_flags(ss_args.flags, required_flags)) {&#13;
        if (op_context.is_signer(signers[0])) {&#13;
            return utils.VALID;&#13;
        } else {&#13;
            return utils.invalid("The auth descriptor signer did not sign the transaction.");&#13;
        }&#13;
    } else {&#13;
        return utils.invalid("Some required flags " + required_flags.to_text() + " are missing on the (single sig) Auth Descriptor.");&#13;
    }&#13;
}&#13;
&#13;
/*&#13;
 * Returns VALID if valid.&#13;
 */&#13;
function check_multi_sig_auth(args: byte_array, signers: list&lt;byte_array&gt;, required_flags: list&lt;text&gt;): utils.validation_result {&#13;
    val multi_sign_args = multi_sig_args.from_bytes(args);&#13;
    if (not (check_required_flags(multi_sign_args.flags, required_flags))) {&#13;
       return utils.invalid("Some required flags " + required_flags.to_text() + " are missing on the (multi sig) Auth Descriptor.");&#13;
    }&#13;
    var num_sign = multi_sign_args.signatures_required;&#13;
    for(s in signers) {&#13;
        if(op_context.is_signer(s)) {&#13;
            num_sign -= 1;&#13;
            if(num_sign &lt; 1) {&#13;
                return utils.VALID;&#13;
            }&#13;
        }&#13;
    }&#13;
    return utils.invalid("Transaction must be signed by at least " + multi_sign_args.signatures_required + " signers in the Auth Descriptor.");&#13;
}&#13;
&#13;
/*&#13;
 * Returns false if any of the required flags are missing from the "flags" set.&#13;
 */&#13;
function check_required_flags(flags: set&lt;text&gt;, required_flags: list&lt;text&gt;): boolean {&#13;
    return flags.contains_all(required_flags);&#13;
}&#13;
&#13;
/*&#13;
 * Returns the set of flags found in the "args" parameter.&#13;
 */&#13;
function get_flags_from_args(a_t: auth_type, args: byte_array): set&lt;text&gt; {&#13;
    return when (a_t) {&#13;
        S -&gt; single_sig_args.from_bytes(args).flags;&#13;
        M -&gt; multi_sig_args.from_bytes(args).flags;&#13;
    };&#13;
}&#13;
&#13;
/*&#13;
 * Returns VALID if authentication arguments are valid.&#13;
 */&#13;
function check_auth_args(a_t: auth_type, args: byte_array, signers: list&lt;byte_array&gt;, required_flags: list&lt;text&gt;): utils.validation_result {&#13;
    return when (a_t) {&#13;
        S -&gt; check_single_sig_auth(args, signers, required_flags);&#13;
        M -&gt; check_multi_sig_auth(args, signers, required_flags);&#13;
    };&#13;
}&#13;
&#13;
function get_signers_from_encoded_auth_descriptor(a_t: auth_type, args: byte_array): list&lt;byte_array&gt; {&#13;
    return when (a_t) {&#13;
        S -&gt; [single_sig_args.from_bytes(args).signer];&#13;
        M -&gt; multi_sig_args.from_bytes(args).signers;&#13;
    };&#13;
}&#13;
&#13;
function get_signers(auth_descriptor)&#13;
    = when (auth_descriptor.auth_type) {&#13;
        S -&gt; [single_sig_args.from_gtv(auth_descriptor.args.to_gtv()).signer];&#13;
        M -&gt; multi_sig_args.from_gtv(auth_descriptor.args.to_gtv()).signers;&#13;
    };&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/core/accounts/auth_descriptor_rule_expression.rell">
                                <string>enum rule_variable {&#13;
&#9;block_height,&#13;
&#9;block_time,&#13;
&#9;op_count&#13;
}&#13;
&#13;
enum rule_operator {&#13;
&#9;lt,&#13;
&#9;le,&#13;
&#9;eq,&#13;
&#9;ge,&#13;
&#9;gt&#13;
}&#13;
&#13;
struct rule_expression {&#13;
&#9;operator: rule_operator;&#13;
&#9;variable: rule_variable;&#13;
&#9;value: integer;&#13;
}&#13;
&#13;
struct rule_parameters {&#13;
&#9;variable: rule_variable;&#13;
&#9;value: integer;&#13;
}&#13;
&#13;
/*&#13;
 * Operator functions&#13;
 */&#13;
&#13;
function greater_than(rule_parameters): rule_expression {&#13;
    return rule_expression(&#13;
        rule_parameters.variable,&#13;
        rule_operator.gt,&#13;
        rule_parameters.value&#13;
    );&#13;
}&#13;
&#13;
function greater_or_equal(rule_parameters): rule_expression {&#13;
    return rule_expression(&#13;
        rule_parameters.variable,&#13;
        rule_operator.ge,&#13;
        rule_parameters.value&#13;
    );&#13;
}&#13;
&#13;
function equals(rule_parameters): rule_expression {&#13;
    return rule_expression(&#13;
        rule_parameters.variable,&#13;
        rule_operator.eq,&#13;
        rule_parameters.value&#13;
    );&#13;
}&#13;
&#13;
function less_than(rule_parameters): rule_expression {&#13;
    return rule_expression(&#13;
        rule_parameters.variable,&#13;
        rule_operator.lt,&#13;
        rule_parameters.value&#13;
    );&#13;
}&#13;
&#13;
function less_or_equal(rule_parameters): rule_expression {&#13;
    return rule_expression(&#13;
        rule_parameters.variable,&#13;
        rule_operator.le,&#13;
        rule_parameters.value&#13;
    );&#13;
}&#13;
&#13;
/*&#13;
 * Rule variable functions&#13;
 */&#13;
&#13;
function block_height(integer): rule_parameters {&#13;
    return rule_parameters(&#13;
        rule_variable.block_height,&#13;
        integer&#13;
    );&#13;
}&#13;
&#13;
function block_time(integer): rule_parameters {&#13;
    return rule_parameters(&#13;
        rule_variable.block_time,&#13;
        integer&#13;
    );&#13;
}&#13;
&#13;
function op_count(integer): rule_parameters {&#13;
    return rule_parameters(&#13;
        rule_variable.op_count,&#13;
        integer&#13;
    );&#13;
}</string>
                            </entry>
                            <entry key="lib/ft4/core/accounts/auth_descriptor_rule_validation.rell">
                                <string>function serialize_rules(rules: list&lt;rule_expression&gt;): gtv {&#13;
&#9;if (rules.size() == 0) {&#13;
&#9;&#9;return GTV_NULL;&#13;
&#9;}&#13;
&#9;if (rules.size() == 1) {&#13;
&#9;&#9;return rule_expression_to_gtv(rules[0]);&#13;
&#9;}&#13;
&#13;
&#9;val rules_gtv = ["and".to_gtv()];&#13;
&#9;for (rule in rules) {&#13;
&#9;&#9;rules_gtv.add(rule_expression_to_gtv(rule));&#13;
&#9;}&#13;
&#9;return rules_gtv.to_gtv();&#13;
}&#13;
&#13;
function rule_expression_to_gtv(rule_expression): gtv = [&#13;
        rule_expression.operator.name.to_gtv(),&#13;
        rule_expression.variable.name.to_gtv(),&#13;
        rule_expression.value.to_gtv()&#13;
    ].to_gtv();&#13;
&#13;
function rule_expression_from_gtv(gtv) {&#13;
&#9;val components = list&lt;gtv&gt;.from_gtv(gtv);&#13;
&#9;val operator_name = text.from_gtv(components[0]);&#13;
&#9;val variable_name = text.from_gtv(components[1]);&#13;
&#9;val value = integer.from_gtv(components[2]);&#13;
&#13;
&#9;val operator = require(&#13;
&#9;&#9;&#9;rule_operator.values() @? { .name == operator_name },&#13;
&#9;&#9;&#9;"Unknown rule operator %s".format(operator_name)&#13;
&#9;);&#13;
&#13;
&#9;val variable = require(&#13;
&#9;&#9;&#9;rule_variable.values() @? { .name == variable_name },&#13;
&#9;&#9;&#9;"Unknown rule variable %s".format(variable_name)&#13;
&#9;);&#13;
&#13;
&#9;return rule_expression(&#13;
&#9;&#9;&#9;operator,&#13;
&#9;&#9;&#9;variable,&#13;
&#9;&#9;&#9;value&#13;
&#9;);&#13;
}&#13;
&#13;
function map_rule_expressions_from_gtv(gtv_rules: list&lt;gtv&gt;) {&#13;
&#9;val rules = list&lt;rule_expression&gt;();&#13;
&#9;for (rule in gtv_rules) {&#13;
&#9;&#9;rules.add(rule_expression_from_gtv(rule));&#13;
&#9;}&#13;
&#9;return rules;&#13;
}&#13;
&#13;
function have_violating_rules(auth_descriptor: account_auth_descriptor) =&#13;
&#9;are_rules_violating(gtv.from_bytes(auth_descriptor.rules), load_variables(auth_descriptor.ctr));&#13;
&#13;
function load_variables(op_count: integer): map&lt;text, gtv&gt; {&#13;
&#9;val variables = map&lt;text, gtv&gt;();&#13;
&#9;variables[rule_variable.op_count.name] = (op_count + 1).to_gtv();&#13;
&#9;variables[rule_variable.block_height.name] = op_context.block_height.to_gtv();&#13;
&#9;variables[rule_variable.block_time.name] = op_context.last_block_time.to_gtv();&#13;
&#9;return variables;&#13;
}&#13;
&#13;
function are_rules_violating(rules: gtv, variables: map&lt;text, gtv&gt;): boolean {&#13;
&#9;if (rules == GTV_NULL) {&#13;
&#9;&#9;return false;&#13;
&#9;}&#13;
&#13;
&#9;val rules_gtv = list&lt;gtv&gt;.from_gtv(rules);&#13;
&#13;
&#9;if (rules_gtv[0] != "and".to_gtv()) {&#13;
&#9;&#9;require(&#13;
&#9;&#9;&#9;rules_gtv.size() == 3,&#13;
&#9;&#9;&#9;"Expected a single rule expression, but got something else"&#13;
&#9;&#9;); // This error will be caught on the next line as well, but like this we can give a better error message&#13;
&#13;
&#9;&#9;return is_rule_violated(rule_expression_from_gtv(rules_gtv.to_gtv()), variables);&#13;
&#9;}&#13;
&#13;
&#9;return are_and_rules_violated(map_rule_expressions_from_gtv(rules_gtv.sub(1)), variables);&#13;
}&#13;
&#13;
function is_rule_violated(rule: rule_expression, variables: map&lt;text, gtv&gt;): boolean {&#13;
&#9;return not evaluate_int_variable_rule(rule, variables);&#13;
}&#13;
&#13;
function are_and_rules_violated(rules: list&lt;rule_expression&gt;, variables: map&lt;text, gtv&gt;): boolean {&#13;
&#9;for (rule in rules) {&#13;
&#9;&#9;if (is_rule_violated(rule, variables)) {&#13;
&#9;&#9;&#9;return true;&#13;
&#9;&#9;}&#13;
&#9;}&#13;
&#9;return false;&#13;
}&#13;
&#13;
function is_active(account_auth_descriptor) = are_rules_active(gtv.from_bytes(account_auth_descriptor.rules));&#13;
&#13;
function are_rules_active(rules: gtv): boolean {&#13;
&#9;if (rules == GTV_NULL) {&#13;
&#9;&#9;return true;&#13;
&#9;}&#13;
&#13;
&#9;val gtv_rules = list&lt;gtv&gt;.from_gtv(rules);&#13;
&#9;if (gtv_rules[0] == "and".to_gtv()) {&#13;
&#9;&#9;for (rule in gtv_rules.sub(1)) {&#13;
&#9;&#9;&#9;if (not is_rule_active(rule_expression_from_gtv(rule))) {&#13;
&#9;&#9;&#9;&#9;return false;&#13;
&#9;&#9;&#9;}&#13;
&#9;&#9;}&#13;
&#9;&#9;return true;&#13;
&#9;}&#13;
&#13;
&#9;return is_rule_active(rule_expression_from_gtv(gtv_rules.to_gtv()));&#13;
}&#13;
&#13;
function is_rule_active(rule: rule_expression): boolean {&#13;
&#9;return when (rule.variable) {&#13;
&#9;&#9;block_height -&gt; is_block_height_rule_active(rule);&#13;
&#9;&#9;block_time -&gt; is_block_time_rule_active(rule);&#13;
&#9;&#9;op_count -&gt; true;&#13;
&#9;};&#13;
}&#13;
&#13;
/*&#13;
 *  Variables&#13;
 */&#13;
&#13;
function evaluate_int_variable_rule(&#13;
&#9;rule: rule_expression,&#13;
&#9;variables: map&lt;text, gtv&gt;&#13;
): boolean {&#13;
&#9;val current_value = variable_value(&#13;
&#9;&#9;rule.variable,&#13;
&#9;&#9;variables&#13;
&#9;);&#13;
&#9;val defined_value = rule.value;&#13;
&#13;
&#9;when (rule.operator) {&#13;
&#9;&#9;rule_operator.lt -&gt; {&#13;
&#9;&#9;&#9;return current_value &lt; defined_value;&#13;
&#9;&#9;}&#13;
&#9;&#9;rule_operator.le -&gt; {&#13;
&#9;&#9;&#9;return current_value &lt;= defined_value;&#13;
&#9;&#9;}&#13;
&#9;&#9;rule_operator.eq -&gt; {&#13;
&#9;&#9;&#9;return current_value == defined_value;&#13;
&#9;&#9;}&#13;
&#9;&#9;rule_operator.ge -&gt; {&#13;
&#9;&#9;&#9;return current_value &gt;= defined_value;&#13;
&#9;&#9;}&#13;
&#9;&#9;rule_operator.gt -&gt; {&#13;
&#9;&#9;&#9;return current_value &gt; defined_value;&#13;
&#9;&#9;}&#13;
&#9;}&#13;
}&#13;
 &#13;
function variable_value(&#13;
&#9;variable: rule_variable,&#13;
&#9;variables: map&lt;text, gtv&gt;&#13;
): integer {&#13;
&#9;when (variable) {&#13;
&#9;&#9;rule_variable.block_height -&gt; {&#13;
&#9;&#9;&#9;return integer.from_gtv(variables[rule_variable.block_height.name]);&#13;
&#9;&#9;}&#13;
&#9;&#9;rule_variable.block_time -&gt; {&#13;
&#9;&#9;&#9;return integer.from_gtv(variables[rule_variable.block_time.name]);&#13;
&#9;&#9;}&#13;
&#9;&#9;rule_variable.op_count -&gt; {&#13;
&#9;&#9;&#9;return integer.from_gtv(variables[rule_variable.op_count.name]);&#13;
&#9;&#9;}&#13;
&#9;}&#13;
}&#13;
&#13;
/*&#13;
 * Analyze the rules before assigning them to an authenticator descriptor&#13;
 */&#13;
function validate_auth_descriptor_rules(rules: gtv) {&#13;
 &#9;if (rules == GTV_NULL) {&#13;
&#9;&#9;return;&#13;
&#9;}&#13;
&#13;
&#9;val rules_gtv = list&lt;gtv&gt;.from_gtv(rules);&#13;
&#9;if (rules_gtv[0] != "and".to_gtv()) {&#13;
&#9;&#9;validate_rule(rule_expression_from_gtv(rules_gtv.to_gtv()));&#13;
&#9;} else {&#13;
&#9;&#9;// +1 keeps track of the "and"&#13;
&#9;&#9;require(rules_gtv.size() &lt;= chain_context.args.auth_descriptor.max_rules + 1, "Too many rules");&#13;
&#13;
&#9;&#9;for (gtv_rule in rules_gtv.sub(1)) {&#13;
&#9;&#9;&#9;validate_rule(rule_expression_from_gtv(gtv_rule));&#13;
&#9;&#9;}&#13;
&#9;}&#13;
&#13;
&#9;require((not are_rules_active(rules)) or (not are_rules_violating(rules, load_variables(op_count = 0))),&#13;
&#9;&#9;"Active and invalid rules detected");&#13;
}&#13;
&#13;
function validate_rule(rule: rule_expression) {&#13;
&#9;when (rule.variable) {&#13;
&#9;&#9;rule_variable.block_height -&gt; {&#13;
&#9;&#9;&#9;require(rule.value &gt;= 0, "rule variable block_height must be a non-negative value");&#13;
&#9;&#9;}&#13;
&#9;&#9;rule_variable.block_time -&gt; {&#13;
&#9;&#9;&#9;require(rule.value &gt;= 0, "rule variable block_time must be a non-negative value");&#13;
&#9;&#9;}&#13;
&#9;&#9;rule_variable.op_count -&gt; {&#13;
&#9;&#9;&#9;when (rule.operator) {&#13;
&#9;&#9;&#9;&#9;rule_operator.lt -&gt; require(rule.value &gt; 1, "rule variable op_count must be a positive value greater than 1");&#13;
&#9;&#9;&#9;&#9;rule_operator.le -&gt; require(rule.value &gt; 0, "rule variable op_count must be a positive value");&#13;
&#9;&#9;&#9;&#9;else -&gt; require(false, "rule variable op_count must be lt or le");&#13;
&#9;&#9;&#9;}&#13;
&#9;&#9;}&#13;
&#9;}&#13;
}&#13;
&#13;
function update_auth_descriptor_rule_variables(desc: account_auth_descriptor) {&#13;
&#9;desc.ctr += 1;&#13;
&#9;return desc;&#13;
}&#13;
&#13;
/*&#13;
 * auth descriptor cleanup&#13;
 */&#13;
&#13;
function delete_expired_auth_descriptors(account) {&#13;
&#9;val auth_descriptors = account_auth_descriptor @* { account };&#13;
&#13;
&#9;val deleted_descriptors = set&lt;account_auth_descriptor&gt;();&#13;
&#13;
&#9;for (auth_descriptor in auth_descriptors) {&#13;
&#9;&#9;if (is_active(auth_descriptor) and have_violating_rules(auth_descriptor)) {&#13;
&#9;&#9;&#9;delete_auth_descriptor(auth_descriptor);&#13;
&#9;&#9;&#9;deleted_descriptors.add(auth_descriptor);&#13;
&#9;&#9;}&#13;
&#9;}&#13;
&#13;
&#9;return deleted_descriptors;&#13;
}&#13;
&#13;
/****************************************************************************************&#13;
 *                                     block_time                                       *&#13;
 ****************************************************************************************/&#13;
&#13;
function is_block_time_rule_active(r: rule_expression): boolean {&#13;
&#9;when (r.operator) {&#13;
&#9;&#9;rule_operator.gt -&gt; {&#13;
&#9;&#9;&#9;return op_context.last_block_time &gt; r.value;&#13;
&#9;&#9;}&#13;
&#9;&#9;rule_operator.ge,&#13;
&#9;&#9;rule_operator.eq -&gt; {&#13;
&#9;&#9;&#9;return op_context.last_block_time &gt;= r.value;&#13;
&#9;&#9;}&#13;
&#9;&#9;else -&gt; {&#13;
&#9;&#9;&#9;return true;&#13;
&#9;&#9;}&#13;
&#9;}&#13;
}&#13;
&#13;
&#13;
/****************************************************************************************&#13;
 *                                  block_height                                        *&#13;
 ****************************************************************************************/&#13;
&#13;
function is_block_height_rule_active(r: rule_expression): boolean {&#13;
&#9;when (r.operator) {&#13;
&#9;&#9;rule_operator.gt -&gt; {&#13;
&#9;&#9;&#9;return op_context.block_height &gt; r.value;&#13;
&#9;&#9;}&#13;
&#9;&#9;rule_operator.ge,&#13;
&#9;&#9;rule_operator.eq -&gt; {&#13;
&#9;&#9;&#9;return op_context.block_height &gt;= r.value;&#13;
&#9;&#9;}&#13;
&#9;&#9;else -&gt; {&#13;
&#9;&#9;&#9;return true;&#13;
&#9;&#9;}&#13;
&#9;}&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/core/accounts/auth_external.rell">
                                <string>&#13;
function AuthDescriptor(id: byte_array) = require(&#13;
    account_auth_descriptor @? { id },&#13;
    "Provided auth descriptor id does not exist %s".format(id)&#13;
);&#13;
&#13;
function Account(id: byte_array) = require(&#13;
    account @? { id },&#13;
    "Account not found: %s".format(id)&#13;
);&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/core/accounts/auth_flags_config.rell">
                                <string>&#13;
struct auth_flags_config {&#13;
    mandatory: gtv = ["A", "T"].to_gtv();&#13;
    default: gtv? = null;&#13;
}&#13;
&#13;
function get_raw_auth_flags_config() {&#13;
    return chain_context.args.auth_flags;&#13;
}&#13;
&#13;
function get_auth_flags_config() {&#13;
    val flags = chain_context.args.auth_flags;&#13;
    val mandatory = parse_auth_flags(flags.mandatory);&#13;
    val default = if (flags.default??) parse_auth_flags(flags.default!!) else mandatory;&#13;
&#13;
    return (&#13;
        mandatory = mandatory,&#13;
        default = default&#13;
    );&#13;
}&#13;
&#13;
function parse_auth_flags(gtv) {&#13;
    var flags = list&lt;text&gt;();&#13;
    &#13;
    if (utils.is_list(gtv)) {&#13;
        flags = require(&#13;
            try_call(list&lt;text&gt;.from_gtv(gtv, *)),&#13;
            "Cannot parse auth flags. Expected flags list, but found &lt;%s&gt;".format(gtv)&#13;
        );&#13;
    } else if (utils.is_text(gtv)) {&#13;
        flags = (text.from_gtv(gtv).split(",")) @* {} ($.trim());&#13;
    } else {&#13;
        require(false, "Expected flags list or comma separated flags list, but found &lt;%s&gt;".format(gtv));&#13;
    }&#13;
&#13;
    require_valid_auth_flags(flags);&#13;
&#13;
    return flags;&#13;
}&#13;
&#13;
function require_valid_auth_flags(flags: list&lt;text&gt;) {&#13;
    val invalid_flags = flags @* { not $.matches("[a-z_A-Z]+") };&#13;
    require(&#13;
        empty(invalid_flags),&#13;
        "Found invalid flags &lt;%s&gt;".format(invalid_flags)&#13;
    );&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/core/accounts/module.rell">
                                <string>@mount('ft4')&#13;
module;&#13;
&#13;
import ^^.utils;&#13;
import ^^.version;&#13;
&#13;
val GTV_NULL = null.to_gtv();&#13;
val GTV_NULL_BYTES = null.to_gtv().to_bytes();&#13;
&#13;
struct rate_limit_config {&#13;
    active: boolean = true;&#13;
&#9;max_points: integer = 10;&#13;
    recovery_time: integer = 5000;&#13;
    points_at_account_creation: integer = 1;&#13;
}&#13;
&#13;
struct auth_descriptor_config {&#13;
    max_rules: integer = 8;&#13;
    max_number_per_account: integer = 10;&#13;
}&#13;
&#13;
struct module_args {&#13;
&#9;rate_limit: rate_limit_config = rate_limit_config();&#13;
    auth_descriptor: auth_descriptor_config = auth_descriptor_config();&#13;
    auth_flags: auth_flags_config = auth_flags_config();&#13;
}&#13;
&#13;
val AUTH_DESCRIPTORS_PER_ACCOUNT_UPPER_BOUND = min(&#13;
    200,&#13;
    chain_context.args.auth_descriptor.max_number_per_account&#13;
);&#13;
&#13;
function get_auth_descriptor_config() = chain_context.args.auth_descriptor;&#13;
&#13;
/**&#13;
 * Constant that represents account type for regular user accounts &#13;
 * created with `create_account_with_auth`.&#13;
 */&#13;
val ACCOUNT_TYPE_USER = "FT4_USER";&#13;
&#13;
enum auth_type {&#13;
    S, M,&#13;
}&#13;
&#13;
struct auth_descriptor {&#13;
    auth_type;&#13;
    args: list&lt;gtv&gt;;&#13;
    rules: gtv;&#13;
}&#13;
&#13;
entity account {&#13;
    key id: byte_array;&#13;
    index type: text;&#13;
}&#13;
&#13;
entity main_auth_descriptor {&#13;
    key account;&#13;
    key auth_descriptor: account_auth_descriptor;&#13;
}&#13;
&#13;
entity account_auth_descriptor {&#13;
    id: byte_array;&#13;
    key account, id;&#13;
    index id;&#13;
    auth_type;&#13;
    args: byte_array;&#13;
    rules: byte_array;&#13;
    mutable ctr: integer;&#13;
    created: timestamp;&#13;
}&#13;
&#13;
entity auth_descriptor_signer {&#13;
    key account_auth_descriptor, id: byte_array;&#13;
}&#13;
&#13;
// rate limiter&#13;
entity rl_state {&#13;
    key account;&#13;
    mutable points: integer;&#13;
    mutable last_update: timestamp;&#13;
    mutable recovery_time: timestamp;&#13;
}&#13;
&#13;
&#13;
function add_auth_descriptor(account, auth_descriptor): account_auth_descriptor {&#13;
    require(&#13;
        (account_auth_descriptor @ { account } (@sum 1))  &lt;&#13;
            AUTH_DESCRIPTORS_PER_ACCOUNT_UPPER_BOUND,&#13;
        "Max &lt;%d&gt; auth descriptor count reached. Delete some before adding new ones."&#13;
            .format(AUTH_DESCRIPTORS_PER_ACCOUNT_UPPER_BOUND)&#13;
    );&#13;
    &#13;
    val id = auth_descriptor.hash();&#13;
&#13;
    validate_auth_descriptor_args(auth_descriptor);&#13;
    validate_auth_descriptor_rules(auth_descriptor.rules);&#13;
&#13;
    val account_auth_descriptor = create account_auth_descriptor (&#13;
        account, &#13;
        id,&#13;
        auth_descriptor.auth_type,&#13;
        args = auth_descriptor.args.to_gtv().to_bytes(),&#13;
        rules = auth_descriptor.rules.to_gtv().to_bytes(),&#13;
        created = utils.latest_time(),&#13;
        ctr = 0&#13;
    );&#13;
&#13;
    add_signers(account, auth_descriptor, account_auth_descriptor);&#13;
    return account_auth_descriptor;&#13;
}&#13;
&#13;
/**&#13;
 * Deletes old main auth descriptor and sets provided auth descriptor as main auth descriptor&#13;
 */&#13;
function update_main_auth_descriptor(account, auth_descriptor) {&#13;
    require(auth_descriptor.rules == GTV_NULL, "Main auth descriptor cannot be restricted");&#13;
    require_mandatory_flags(auth_descriptor);&#13;
    delete_main_auth_descriptor(account);&#13;
    val account_auth_descriptor = add_auth_descriptor(account, auth_descriptor);&#13;
    set_main_auth_descriptor(account, account_auth_descriptor);&#13;
}&#13;
&#13;
function delete_main_auth_descriptor(account) {&#13;
    val main_auth_descriptor = require(&#13;
        main_auth_descriptor @? { account },&#13;
        "Error deleting main auth descriptor of account &lt;%s&gt;. Auth descriptor not found".format(account.id)&#13;
    );&#13;
&#13;
    val auth_descriptor = main_auth_descriptor.auth_descriptor;&#13;
    delete main_auth_descriptor;&#13;
    delete_auth_descriptor(auth_descriptor);&#13;
}&#13;
&#13;
function set_main_auth_descriptor(account, account_auth_descriptor) {&#13;
    require(&#13;
        empty(main_auth_descriptor @? { account }),&#13;
        "Error setting main auth descriptor. Main auth descriptor already exists"&#13;
    );&#13;
&#13;
    create main_auth_descriptor(account, account_auth_descriptor);&#13;
}&#13;
&#13;
function delete_auth_descriptor(auth_descriptor: account_auth_descriptor) {&#13;
    require(&#13;
        main_auth_descriptor @? { auth_descriptor } == null,&#13;
        "Cannot delete main auth descriptor"&#13;
    );&#13;
    delete auth_descriptor_signer @* { auth_descriptor };&#13;
    delete auth_descriptor;&#13;
}&#13;
&#13;
function delete_all_auth_descriptors_except_main(account) {&#13;
    val main = main_auth_descriptor @ { account } ( .auth_descriptor );&#13;
    delete (ads: auth_descriptor_signer, ad: account_auth_descriptor) @* {&#13;
        ad.account == account,&#13;
        ad != main,&#13;
        ads.account_auth_descriptor == ad&#13;
    };&#13;
&#13;
    delete account_auth_descriptor @* {&#13;
       .account == account,&#13;
       $ != main&#13;
    };&#13;
}&#13;
&#13;
function create_account_with_auth(auth_descriptor, account_id: byte_array? = null): account {&#13;
    require(auth_descriptor.rules == GTV_NULL, "Cannot create an account with a restricted auth descriptor");&#13;
    require_mandatory_flags(auth_descriptor);&#13;
&#13;
    val id = account_id ?: get_account_id_from_signers(get_signers(auth_descriptor));&#13;
    val account = create account(id, type = ACCOUNT_TYPE_USER);&#13;
&#13;
    val main = add_auth_descriptor(account, auth_descriptor);&#13;
    create main_auth_descriptor(account, main);&#13;
&#13;
    create_rate_limiter_state_for_account(account);&#13;
    &#13;
    return account;&#13;
}&#13;
&#13;
function require_mandatory_flags(auth_descriptor) {&#13;
    var flags = get_flags(auth_descriptor);&#13;
    val mandatory = get_auth_flags_config().mandatory;&#13;
    require(&#13;
        flags.contains_all(mandatory),&#13;
        "Some of mandatory flags &lt;%s&gt; missing, found only &lt;%s&gt;".format(mandatory, flags)&#13;
    );&#13;
}&#13;
&#13;
/**&#13;
 * Creates an account without auth descriptor. Used to create different "system" account types,&#13;
 * that cannot be directly accessed, e.g. POOL, FEE, BLOCKCHAIN, ... accounts.&#13;
 * &#13;
 * @param account_id    account id&#13;
 * @param type          account type specified as a free form text. Usually uppercase.&#13;
 */&#13;
function create_account_without_auth(account_id: byte_array, type: text): account {&#13;
    return create account(&#13;
        id = account_id,&#13;
        type = type&#13;
    );&#13;
}&#13;
&#13;
/**&#13;
 * Finds or creates an account of specific type.&#13;
 *&#13;
 * @param account_id    account id&#13;
 * @param type          account type &#13;
 */&#13;
function ensure_account_without_auth(account_id: byte_array, type: text): account {&#13;
    val account = account @? { .id == account_id };&#13;
    if (account??) {&#13;
        require(&#13;
            account.type == type,&#13;
            "Found account &lt;%s&gt; of invalid type. Expected &lt;%s&gt;, found &lt;%s&gt;".format(account.id, type, account.type)&#13;
        );&#13;
&#13;
        return account;&#13;
    } else {&#13;
        return create_account_without_auth(account_id, type);&#13;
    }&#13;
}&#13;
&#13;
function get_flags(auth_descriptor) {&#13;
    return when (auth_descriptor.auth_type) {&#13;
        S -&gt; single_sig_args.from_gtv(auth_descriptor.args.to_gtv()).flags;&#13;
        M -&gt; multi_sig_args.from_gtv(auth_descriptor.args.to_gtv()).flags;&#13;
    };&#13;
}&#13;
&#13;
/**&#13;
* Checks if an `account_auth_descriptor` has all the specified flags&#13;
*/&#13;
function has_flags(account_auth_descriptor, required_flags: list&lt;text&gt;): boolean {&#13;
    val flags = get_flags_from_args(account_auth_descriptor.auth_type, account_auth_descriptor.args);&#13;
    return flags.contains_all(required_flags);&#13;
}&#13;
&#13;
function add_signers(account, auth_descriptor, account_auth_descriptor) {&#13;
    create auth_descriptor_signer(&#13;
        get_signers(auth_descriptor) @* {}&#13;
            (struct&lt;auth_descriptor_signer&gt;(account_auth_descriptor, id = $))&#13;
    );&#13;
}&#13;
&#13;
function get_account_id_from_signers(signers: list&lt;byte_array&gt;) {&#13;
    require(signers.size() &gt; 0, "Cannot derive account id. Signers list is empty");&#13;
    return if (signers.size() == 1) signers[0].hash() else signers @* {} (@sort $).hash();&#13;
}&#13;
&#13;
function auth_descriptor_by_id(account, id: byte_array) = require(&#13;
    account_auth_descriptor @? { account, id },&#13;
    "Auth descriptor '%s' not found for account '%s'".format(id, account.id)&#13;
);&#13;
&#13;
function account_by_id(id: byte_array) = require(&#13;
    account @? { id },&#13;
    "Account not found: '%s'".format(id)&#13;
);&#13;
&#13;
function single_sig_auth_descriptor(signer: byte_array, flags: set&lt;text&gt;) = auth_descriptor(&#13;
    auth_type = auth_type.S,&#13;
    args = list&lt;gtv&gt;.from_gtv(single_sig_args(&#13;
        flags = flags,&#13;
        signer = signer&#13;
    ).to_gtv()),&#13;
    GTV_NULL&#13;
);&#13;
&#13;
function multi_sig_auth_descriptor(signers: list&lt;byte_array&gt;, signatures_required: integer, flags: set&lt;text&gt;) = auth_descriptor(&#13;
    auth_type = auth_type.M,&#13;
    args = list&lt;gtv&gt;.from_gtv(multi_sig_args(&#13;
        signers = signers,&#13;
        signatures_required = signatures_required,&#13;
        flags = flags&#13;
    ).to_gtv()),&#13;
    GTV_NULL&#13;
);&#13;
&#13;
function get_auth_descriptors(id: byte_array) {&#13;
    return account_auth_descriptor @* {&#13;
        .account.id == id&#13;
    } (&#13;
        get_auth_descriptor_data($.to_struct())&#13;
    );&#13;
}&#13;
&#13;
function get_auth_descriptors_by_signer(account_id: byte_array, signer: byte_array) {&#13;
    return auth_descriptor_signer @* {&#13;
        .account_auth_descriptor.account.id == account_id,&#13;
        .id == signer&#13;
    } (&#13;
        get_auth_descriptor_data(.account_auth_descriptor.to_struct())&#13;
    );&#13;
}&#13;
&#13;
function get_auth_descriptor_data(ad: struct&lt;account_auth_descriptor&gt;) {&#13;
    return (&#13;
        id = ad.id,&#13;
        account_id = ad.account.id,&#13;
        auth_type = ad.auth_type,&#13;
        args = gtv.from_bytes(ad.args),&#13;
        rules = gtv.from_bytes(ad.rules),&#13;
        created = ad.created&#13;
    );&#13;
}&#13;
&#13;
function get_paginated_accounts_by_signer(id: byte_array, page_size: integer?, page_cursor: text?) {&#13;
    val before_rowid = utils.before_rowid(page_cursor);&#13;
    return auth_descriptor_signer @* {&#13;
        id,&#13;
        .rowid &gt; (before_rowid ?: rowid(0))&#13;
    } (&#13;
        utils.pagination_result(&#13;
            data=.account_auth_descriptor.account.to_struct().to_gtv_pretty(),&#13;
            rowid=.rowid&#13;
        )&#13;
    ) limit utils.fetch_data_size(page_size); &#13;
}&#13;
&#13;
function get_paginated_accounts_by_ad_id(id: byte_array, page_size: integer?, page_cursor: text?) {&#13;
    val before_rowid = utils.before_rowid(page_cursor);&#13;
    return account_auth_descriptor @* {&#13;
        .id == id,&#13;
        .rowid &gt; (before_rowid ?: rowid(0))&#13;
    } (&#13;
        utils.pagination_result(&#13;
            data=.account.id.to_gtv_pretty(),&#13;
            rowid=.rowid&#13;
        )&#13;
    ) limit utils.fetch_data_size(page_size);&#13;
}&#13;
&#13;
function get_paginated_accounts_by_type(type: text, page_size: integer?, page_cursor: text?) {&#13;
    val before_rowid = utils.before_rowid(page_cursor);&#13;
    return account @* {&#13;
        .type == type,&#13;
        .rowid &gt; (before_rowid ?: rowid(0))&#13;
    } (&#13;
        utils.pagination_result(&#13;
            data = .id.to_gtv(),&#13;
            rowid = .rowid&#13;
        )&#13;
    ) limit utils.fetch_data_size(page_size);    &#13;
}&#13;
&#13;
function validate_auth_descriptor_args(auth_descriptor) {&#13;
    when (auth_descriptor.auth_type) {&#13;
        S -&gt; single_sig_args.from_gtv(auth_descriptor.args.to_gtv());&#13;
        M -&gt; {&#13;
            val args = multi_sig_args.from_gtv(auth_descriptor.args.to_gtv());&#13;
            require(args.signatures_required &gt; 0, "Required signatures must be positive");&#13;
            require(args.signatures_required &lt;= args.signers.size(), "Required signatures cannot be greater than number of signers");&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
function get_max_allowed_auth_descriptor_rules() = chain_context.args.auth_descriptor.max_rules;&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/core/accounts/rate_limit.rell">
                                <string>/**&#13;
 * Extend this function to have different rate limiting for different accounts.&#13;
 *&#13;
 * @param account  the account&#13;
 *&#13;
 * @return rate limit configuration for the account, or `null` to use default config from blockchain configuration.&#13;
 */&#13;
@extendable&#13;
function account_rate_limit_config(account): rate_limit_config? = null;&#13;
&#13;
function rate_limit(account) {&#13;
    val rl_config = get_rate_limit_config_for_account(account);&#13;
&#13;
    if (rl_config.active == false) return;&#13;
    &#13;
    val max_counter = rl_config.max_points;&#13;
    val recovery_time = rl_config.recovery_time;&#13;
    val stat = require(&#13;
        rl_state@?{account} (.points, .last_update), &#13;
        "Rate limiter state not found for the account with ID: %s".format(account.id)&#13;
    );&#13;
    val delta = utils.latest_time() - stat.last_update;&#13;
    var got_points = 0;&#13;
    var update_time = stat.last_update;&#13;
&#13;
    if (delta &gt; recovery_time) {&#13;
        got_points = delta / recovery_time;&#13;
        update_time = stat.last_update + got_points * recovery_time;&#13;
        if (got_points + stat.points &gt; max_counter) {&#13;
            got_points = max_counter - stat.points;&#13;
            // if user is at maximum reset his timer&#13;
            update_time = utils.latest_time();&#13;
        }&#13;
    }&#13;
    &#13;
    require(stat.points + got_points &gt; 0, "Insufficient rate limiter points");&#13;
    &#13;
    update rl_state @ { account } (&#13;
        .points += got_points - 1,&#13;
        .last_update = update_time&#13;
    );&#13;
}&#13;
&#13;
function current_rate_limit_points(rate_limit_config, rl_state, current_timestamp: timestamp) {&#13;
    val delta = current_timestamp - rl_state.last_update;&#13;
    return if (delta &gt; rate_limit_config.recovery_time)&#13;
        min(rate_limit_config.max_points, rl_state.points + delta / rate_limit_config.recovery_time)&#13;
    else&#13;
        rl_state.points;&#13;
}&#13;
&#13;
function add_rate_limit_points(account, amount: integer) {&#13;
    val state = require(&#13;
        rl_state @? { account }, &#13;
        "Rate limiter state not found for the account with ID: %s".format(account.id)&#13;
    );&#13;
    val config = get_rate_limit_config_for_account(account);&#13;
&#9;state.points = min(state.points + amount, config.max_points);&#13;
}&#13;
&#13;
function get_rate_limit_config(): rate_limit_config = chain_context.args.rate_limit;&#13;
&#13;
function get_rate_limit_config_for_account(account): rate_limit_config =&#13;
    if (chain_context.args.rate_limit.active == false)&#13;
        chain_context.args.rate_limit&#13;
    else&#13;
        account_rate_limit_config(account) ?: chain_context.args.rate_limit;&#13;
&#13;
function create_rate_limiter_state_for_account(account) {&#13;
    val rl_config = get_rate_limit_config_for_account(account);&#13;
&#13;
    val max_points = rl_config.max_points;&#13;
    val recovery_time = rl_config.recovery_time;&#13;
    val points_at_start = min(rl_config.points_at_account_creation, rl_config.max_points);&#13;
    &#13;
    create rl_state(account, .points = points_at_start, .last_update = utils.latest_time(), recovery_time);&#13;
}</string>
                            </entry>
                            <entry key="lib/ft4/core/accounts/strategies/auth_message.rell">
                                <string>&#13;
function get_register_account_message(&#13;
    strategy_operation: gtx_operation,&#13;
    register_account_operation: gtx_operation&#13;
) {&#13;
    val strategy = get_strategy(strategy_operation.name);&#13;
&#13;
    val account_details = strategy.account_details(strategy_operation.args.to_gtv());&#13;
&#13;
    var message = "Blockchain: %s\n\nPlease sign the message to register account\n\nAccount ID:\n%s\n\n"&#13;
        .format(&#13;
            chain_context.blockchain_rid,&#13;
            account_details.account_id&#13;
        );&#13;
&#13;
    message = message + auth_message_operation_details(register_account_operation);&#13;
    message = message + auth_message_auth_descriptors_details(account_details.main, account_details.disposable);&#13;
&#13;
    return message;&#13;
}&#13;
&#13;
function auth_message_operation_details(op: gtx_operation): text {&#13;
    var message = "Operation:\n%s\n\n".format(op.name);&#13;
    if (op.args.size() &gt; 0) {&#13;
        message = message + "Parameters:\n";&#13;
        for (parameter in op.args) {&#13;
            message = message + "- %s\n".format(parameter);&#13;
        }&#13;
        message = message + "\n\n";&#13;
    }&#13;
    return message;&#13;
}&#13;
&#13;
function auth_message_auth_descriptors_details(&#13;
    main: accounts.auth_descriptor, &#13;
    disposable: accounts.auth_descriptor? = null&#13;
): text {&#13;
    var message = "Main:\n" + auth_message_auth_descriptor(main);&#13;
&#13;
    if (disposable??) {&#13;
        message = message + "\n\nDisposable:\n" + auth_message_auth_descriptor(disposable);&#13;
    }&#13;
&#13;
    return message;&#13;
}&#13;
&#13;
function auth_message_auth_descriptor(accounts.auth_descriptor)&#13;
    = when (auth_descriptor.auth_type) {&#13;
        S -&gt; auth_message_single_sig(accounts.single_sig_args.from_gtv(auth_descriptor.args.to_gtv()));&#13;
        M -&gt; auth_message_multi_sig(accounts.multi_sig_args.from_gtv(auth_descriptor.args.to_gtv()));&#13;
    };&#13;
&#13;
function auth_message_single_sig(args: accounts.single_sig_args)&#13;
    = "Signer:\n%s\n\nFlags:\n%s\n".format(args.signer, args.flags);&#13;
&#13;
function auth_message_multi_sig(args: accounts.multi_sig_args) {&#13;
    var message = "Signers:\n";&#13;
    for (signer in args.signers) {&#13;
        message = message + signer + "\n";&#13;
    }&#13;
    message = message + "\nRequired signatures: %d\n\n".format(args.signatures_required);&#13;
    return message + "Flags:\n%s".format(args.flags);&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/core/accounts/strategies/module.rell">
                                <string>@mount("ft4")&#13;
module;&#13;
&#13;
import ^^^.core.accounts;&#13;
import ^^^.core.auth;&#13;
&#13;
function get_strategy(strategy_name: name): _strategy {&#13;
    val strategies = strategy();&#13;
    require(strategy_name in strategies, "Strategy &lt;%s&gt; is not loaded or does not exist.".format(strategy_name));&#13;
    return strategies[strategy_name];&#13;
}&#13;
&#13;
function is_strategy_op(op: gtx_operation): boolean {&#13;
    val strategy_operations = strategy().values() @* {} ($.op.mount_name);&#13;
    return op.name in strategy_operations;&#13;
}&#13;
&#13;
function register_account(): accounts.account {&#13;
    val tx_operations = op_context.get_all_operations();&#13;
    val strategy_op = tx_operations[op_context.op_index-1];&#13;
    val strategy_name = strategy_op.name;&#13;
    val strategy_params = strategy_op.args.to_gtv();&#13;
&#13;
    val strategy = get_strategy(strategy_name);&#13;
    val account_details = strategy.account_details(strategy_params);&#13;
&#13;
    var signers = accounts.get_signers(account_details.main);&#13;
    if (account_details.disposable??) {&#13;
        signers.add_all(accounts.get_signers(account_details.disposable!!));&#13;
    }&#13;
&#13;
    val message = get_register_account_message(strategy_op, op_context.get_current_operation());&#13;
    auth.verify_signers_with_message(signers, message);&#13;
&#13;
    val account_id = account_details.account_id;&#13;
&#13;
    before_register_account(account_id);&#13;
&#13;
    val account = accounts.create_account_with_auth(account_details.main, account_id);&#13;
    if (account_details.disposable??) {&#13;
        accounts.add_auth_descriptor(account, account_details.disposable!!);&#13;
    }&#13;
&#13;
    strategy.action(account, strategy_params);&#13;
&#13;
    after_register_account(account);&#13;
&#13;
    return account;&#13;
}&#13;
&#13;
@extendable function before_register_account(account_id: byte_array);&#13;
&#13;
@extendable function after_register_account(accounts.account);&#13;
&#13;
@extendable &#13;
function strategy(): map&lt;name, _strategy&gt;;&#13;
&#13;
struct _strategy {&#13;
    op: rell.meta;&#13;
    account_details: (gtv) -&gt; account_details;&#13;
    action: (accounts.account, gtv) -&gt; unit;&#13;
}&#13;
&#13;
struct account_details {&#13;
    account_id: byte_array;&#13;
    main: accounts.auth_descriptor;&#13;
    disposable: accounts.auth_descriptor? = null;&#13;
}&#13;
&#13;
function add_strategy(op: rell.meta, account_details: (gtv) -&gt; account_details, action: ((accounts.account, gtv) -&gt; unit)? = null)&#13;
    = [op.mount_name: _strategy(op, account_details, action ?: _no_action(*))];&#13;
&#13;
function _no_action(accounts.account, strategy_params: gtv) {}&#13;
&#13;
function require_register_account_next_operation() {&#13;
    val all_operations = op_context.get_all_operations();&#13;
    val this_op = op_context.get_all_operations()[op_context.op_index];&#13;
    &#13;
    require(&#13;
        all_operations.size() &gt; op_context.op_index + 1,&#13;
        "&lt;%s&gt; must be followed by a register account operation".format(this_op.name)&#13;
    );&#13;
    &#13;
    val next_op = all_operations[op_context.op_index + 1];&#13;
&#13;
    require(&#13;
        auth.is_evm_signatures_authorized_operation(next_op.name),&#13;
        "&lt;%s&gt; operation must be followed by a register account operation, not &lt;%s&gt;".format(this_op.name, next_op.name)&#13;
    );&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/core/accounts/strategies/open/module.rell">
                                <string>@mount("ft4")&#13;
module;&#13;
&#13;
import ^^^^.core.accounts;&#13;
import ^^^^.core.accounts.strategies;&#13;
&#13;
operation ras_open(&#13;
    main: accounts.auth_descriptor,&#13;
    disposable: accounts.auth_descriptor? = null&#13;
) {&#13;
    strategies.require_register_account_next_operation();&#13;
}&#13;
&#13;
function account_details(gtv) {&#13;
    val params = struct&lt;ras_open&gt;.from_gtv(gtv);&#13;
    val signers = accounts.get_signers(params.main);&#13;
    return strategies.account_details(&#13;
        account_id = accounts.get_account_id_from_signers(signers),&#13;
        main = params.main,&#13;
        disposable = params.disposable&#13;
    );&#13;
}&#13;
&#13;
@extend(strategies.strategy)&#13;
function () = strategies.add_strategy(&#13;
    op = rell.meta(ras_open),&#13;
    account_details = account_details(*)&#13;
);&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/core/auth/authentication.rell">
                                <string>/**&#13;
 * This function can be extended by users to add custom logic before authentication.&#13;
 */&#13;
@extendable&#13;
function before_authenticate(accounts.account, accounts.account_auth_descriptor);&#13;
&#13;
/**&#13;
 * This function can be extended by users to add custom logic after authentication.&#13;
 */&#13;
@extendable&#13;
function after_authenticate(accounts.account, accounts.account_auth_descriptor?);&#13;
&#13;
val EVM_AUTH_OP = "ft4.evm_auth";&#13;
val FT_AUTH_OP = "ft4.ft_auth";&#13;
&#13;
val EVM_ADDRESS_SIZE = 20;&#13;
val FT_PUBKEY_SIZE = 33;&#13;
&#13;
val BLOCKCHAIN_RID_PLACEHOLDER = "{blockchain_rid}";&#13;
val ACCOUNT_ID_PLACEHOLDER = "{account_id}";&#13;
val AUTH_DESCRIPTOR_ID_PLACEHOLDER = "{auth_descriptor_id}";&#13;
val NONCE_PLACEHOLDER = "{nonce}";&#13;
&#13;
function authenticate() {&#13;
    val op = op_context.get_current_operation();&#13;
    require(op_context.op_index &gt; 0, "Expected at least two operations, make sure that you included auth operation.");&#13;
&#13;
    val previous_op = op_context.get_all_operations()[op_context.op_index - 1];&#13;
    require(&#13;
        is_auth_op(previous_op),&#13;
        "Error authorizing operation. Incorrect auth operation %s".format(previous_op.name)&#13;
    );&#13;
&#13;
    val (account, auth_descriptor) = fetch_account_and_auth_descriptor(previous_op.args);&#13;
    require(&#13;
        get_first_allowed_auth_descriptor(op.name, op.args.to_gtv(), account.id, [auth_descriptor.id]),&#13;
        "The provided auth descriptor is not valid for this operation"&#13;
    );&#13;
    before_authenticate(account, auth_descriptor);&#13;
&#13;
    accounts.rate_limit(account);&#13;
&#13;
    require(not accounts.have_violating_rules(auth_descriptor), "The rules for this auth descriptor have been violated");&#13;
&#13;
    val flags = get_auth_flags(op.name);&#13;
&#13;
    when (previous_op.name) {&#13;
        EVM_AUTH_OP -&gt; _validate_evm_signature(op, previous_op, flags, account, auth_descriptor);&#13;
        FT_AUTH_OP -&gt; _validate_ft4_signature(flags, account, auth_descriptor);&#13;
        else -&gt; require(false, "Invalid auth operation: %s".format(previous_op.name));&#13;
    };&#13;
&#13;
    val auth_desc_after = accounts.update_auth_descriptor_rule_variables(auth_descriptor);&#13;
    val deleted_descriptors = accounts.delete_expired_auth_descriptors(account);&#13;
&#13;
    after_authenticate(account, if (auth_desc_after in deleted_descriptors) null else auth_desc_after);&#13;
&#13;
    return account;&#13;
}&#13;
&#13;
function get_first_allowed_auth_descriptor_by_signers(op_name: name, args: gtv, account_id: byte_array, signers: list&lt;byte_array&gt;) {&#13;
    val ads = accounts.auth_descriptor_signer @* {&#13;
        .account_auth_descriptor.account.id == account_id,&#13;
        .id in signers&#13;
    } (.account_auth_descriptor);&#13;
&#13;
    val flags = get_auth_flags(op_name);&#13;
&#13;
    val valid_ad_ids = ads @* { accounts.has_flags($, flags) } (.id);&#13;
&#13;
    return get_first_allowed_auth_descriptor(op_name, args, account_id, valid_ad_ids);&#13;
}&#13;
&#13;
function get_first_allowed_auth_descriptor(op_name: name, args: gtv, account_id: byte_array, ad_ids: list&lt;byte_array&gt;) {&#13;
    if (ad_ids.size() == 0) return null;&#13;
&#13;
    val resolver = get_auth_handler(op_name).resolver;&#13;
    if (resolver == null) return ad_ids[0];&#13;
  &#13;
    return resolver(args, account_id, ad_ids);&#13;
}&#13;
&#13;
function fetch_account_and_auth_descriptor(auth_args: list&lt;gtv&gt;): (accounts.account, accounts.account_auth_descriptor) {&#13;
    val (account_id, auth_descriptor_id) = extract_account_and_auth_descriptor(auth_args);&#13;
    val account = accounts.Account(account_id);&#13;
    val auth_descriptor = require(&#13;
        try_fetch_auth_descriptor(account, auth_descriptor_id),&#13;
        "Auth descriptor '%s' not found for account '%s'".format(auth_descriptor_id, account_id)&#13;
    );&#13;
    return (account, auth_descriptor);&#13;
}&#13;
&#13;
function extract_account_and_auth_descriptor(auth_args: list&lt;gtv&gt;): (byte_array, byte_array) {&#13;
    val account_id = byte_array.from_gtv(auth_args[0]);&#13;
    val auth_descriptor_id = byte_array.from_gtv(auth_args[1]);&#13;
    return (account_id, auth_descriptor_id);&#13;
}&#13;
&#13;
function try_fetch_auth_descriptor(accounts.account, auth_descriptor_id: byte_array): accounts.account_auth_descriptor? =&#13;
    accounts.account_auth_descriptor @? { .id == auth_descriptor_id, .account == account };&#13;
&#13;
function get_auth_flags(op_name: name) = get_auth_handler(op_name).flags;&#13;
&#13;
function get_auth_message_template(op_name: name, op_args: gtv?) {&#13;
    val formatter = get_auth_handler(op_name).message_formatter;&#13;
&#13;
    val args = if (op_args == null) list&lt;gtv&gt;() else list&lt;gtv&gt;.from_gtv(op_args);&#13;
&#13;
    val message = if (formatter??) formatter(args.to_gtv()) else generate_operation_auth_message(chain_context.blockchain_rid, gtx_operation(&#13;
        name = op_name,&#13;
        args = args&#13;
    ));&#13;
&#13;
    return utils.make_auth_message(message);&#13;
}&#13;
&#13;
function _validate_evm_signature(&#13;
  op: gtx_operation,&#13;
  auth_op: gtx_operation,&#13;
  flags: list&lt;text&gt;,&#13;
  account: accounts.account,&#13;
  auth_descriptor: accounts.account_auth_descriptor&#13;
) {&#13;
    val message_template = get_auth_message_template(op.name, op.args.to_gtv());&#13;
    val validated_args = _validate_evm_arguments(auth_op.args, set(flags), account, auth_descriptor);&#13;
    val message = create_message_from_template(&#13;
        validated_args, &#13;
        message_template, &#13;
        op.args, &#13;
        utils.derive_nonce(op, auth_descriptor.ctr)&#13;
    );&#13;
&#13;
    if (auth_descriptor.auth_type == accounts.auth_type.S)&#13;
        _validate_evm_address(message, validated_args.signatures[0], auth_descriptor);&#13;
    else&#13;
        _validate_multiple_evm_addresses(message, validated_args.signatures, auth_descriptor);&#13;
}&#13;
&#13;
function create_message_from_template(evm_auth_args, message_template: text, args: list&lt;gtv&gt;, nonce: text): text {&#13;
    require(message_template.contains(NONCE_PLACEHOLDER), "Message template has to include '%s'".format(NONCE_PLACEHOLDER));&#13;
    require(message_template.contains(BLOCKCHAIN_RID_PLACEHOLDER), "Message template has to include '%s'".format(BLOCKCHAIN_RID_PLACEHOLDER));&#13;
    var message = message_template;&#13;
    &#13;
    return message&#13;
        .replace(ACCOUNT_ID_PLACEHOLDER, evm_auth_args.account.id.to_hex().upper_case())&#13;
        .replace(AUTH_DESCRIPTOR_ID_PLACEHOLDER, evm_auth_args.account_auth_descriptor.id.to_hex().upper_case())&#13;
        .replace(NONCE_PLACEHOLDER, nonce)&#13;
        .replace(BLOCKCHAIN_RID_PLACEHOLDER, chain_context.blockchain_rid.to_hex().upper_case());&#13;
}&#13;
&#13;
function _validate_evm_arguments(&#13;
  auth_args: list&lt;gtv&gt;,&#13;
  required_flags: set&lt;text&gt;,&#13;
  account: accounts.account, &#13;
  auth_descriptor: accounts.account_auth_descriptor&#13;
): evm_auth_args {&#13;
    require(auth_args.size() == 3, "Incorrect number of arguments to auth operation");&#13;
&#13;
    val signatures = list&lt;signature?&gt;.from_gtv(auth_args[2]);&#13;
&#13;
    val has_all_flags = accounts.has_flags(auth_descriptor, list(required_flags));&#13;
    &#13;
    require(has_all_flags, "The auth descriptor does not have the required permissions");&#13;
&#13;
    return evm_auth_args(account, auth_descriptor, signatures);&#13;
}&#13;
&#13;
function _validate_ft4_signature(&#13;
  flags: list&lt;text&gt;,&#13;
  account: accounts.account,&#13;
  auth_descriptor: accounts.account_auth_descriptor&#13;
) {&#13;
   &#9;val result: utils.validation_result = accounts.check_auth_args(&#13;
        auth_descriptor.auth_type,&#13;
        auth_descriptor.args,&#13;
        accounts.get_signers_from_encoded_auth_descriptor(auth_descriptor.auth_type, auth_descriptor.args),&#13;
        flags&#13;
   &#9;);&#13;
&#13;
    require(result.valid, result.error!!); // Prints a precise error message.&#13;
}&#13;
&#13;
function _recover_evm_address(message: text, signature) {&#13;
    require(message != "", "Empty messages are not allowed");&#13;
&#13;
    val msg_hash = _evm_message_hash(message);&#13;
    val evm_pubkey = crypto.eth_ecrecover(&#13;
        signature.r,&#13;
        signature.s,&#13;
        signature.v - 27,&#13;
        msg_hash&#13;
    );&#13;
    &#13;
    return crypto.eth_pubkey_to_address(evm_pubkey);&#13;
}&#13;
&#13;
function _evm_message_hash(message: text): byte_array =&#13;
    keccak256(("\u0019Ethereum Signed Message:\n" + message.to_bytes().size().to_text() + message).to_bytes());&#13;
&#13;
function _validate_evm_address(message: text, signature?, accounts.account_auth_descriptor) {&#13;
    require(signature, "Signature cannot be null when using single sig");&#13;
    val recovered_address = _recover_evm_address(message, signature);&#13;
    val signer = accounts.auth_descriptor_signer @? {&#13;
        .account_auth_descriptor == account_auth_descriptor,&#13;
        .id == recovered_address&#13;
    };&#13;
    require(signer, "Invalid signature on message: \n%s".format(message));&#13;
&#13;
    return recovered_address;&#13;
}&#13;
&#13;
function _validate_multiple_evm_addresses(message: text, signatures: list&lt;signature?&gt;, accounts.account_auth_descriptor) {&#13;
    val recovered_keys = list&lt;byte_array&gt;();&#13;
    val ad_args = accounts.multi_sig_args.from_bytes(account_auth_descriptor.args);&#13;
    for (i in range(signatures.size())) {&#13;
        if (signatures[i] == null) continue;&#13;
&#13;
        val recovered_address = _validate_evm_address(&#13;
            message,&#13;
            signatures[i],&#13;
            account_auth_descriptor&#13;
        );&#13;
        require(&#13;
            recovered_address == ad_args.signers[i],&#13;
            "Expected signer at index &lt;%d&gt; to be &lt;%s&gt; but was: &lt;%s&gt;"&#13;
                .format(i, ad_args.signers[i], recovered_address)&#13;
        );&#13;
        recovered_keys.add(recovered_address);&#13;
    }&#13;
    require(&#13;
        recovered_keys.size() &gt;= ad_args.signatures_required, &#13;
        "Minimum number of valid signatures not reached. Expected &lt;%d&gt;, found &lt;%d&gt;."&#13;
            .format(ad_args.signatures_required, recovered_keys.size())&#13;
    );&#13;
    return recovered_keys;&#13;
}&#13;
&#13;
/**&#13;
  * Verifies whether provided list of signers have signed the operation/transaction.&#13;
  * FT (GTX) signers are checked against GTX `signers` and `signatures` fields, while &#13;
  * EVM signers are checked against signers and signatures provided in `ft4.evm_signatures` operation.&#13;
  */&#13;
function verify_signers(ft_and_evm_signers: list&lt;byte_array&gt;) {&#13;
    val op = op_context.get_current_operation();&#13;
    val message_template = get_auth_message_template(op.name, op.args.to_gtv());&#13;
&#13;
    var message = message_template&#13;
        .replace(BLOCKCHAIN_RID_PLACEHOLDER, chain_context.blockchain_rid.to_hex().upper_case())&#13;
        .replace(NONCE_PLACEHOLDER, utils.derive_nonce(op, 0));&#13;
&#13;
    if (message_template.contains(ACCOUNT_ID_PLACEHOLDER) or message_template.contains(AUTH_DESCRIPTOR_ID_PLACEHOLDER)) {&#13;
        val auth_details = require(&#13;
            get_auth_details_from_auth_operation(),&#13;
            "Cannot extract auth details. Auth operation not found"&#13;
        );&#13;
        &#13;
        message = message&#13;
            .replace(ACCOUNT_ID_PLACEHOLDER, auth_details.account_id.to_hex().upper_case())&#13;
            .replace(AUTH_DESCRIPTOR_ID_PLACEHOLDER, auth_details.auth_descriptor_id.to_hex().upper_case());&#13;
    }&#13;
&#13;
    verify_signers_with_message(ft_and_evm_signers, message);&#13;
}&#13;
&#13;
function verify_signers_with_message(ft_and_evm_signers: list&lt;byte_array&gt;, message: text) {&#13;
    val (signers, signatures) = get_evm_signatures();&#13;
    for (i in range(signatures.size())) {&#13;
        val signer = signers[i];&#13;
        require(&#13;
            signer == _recover_evm_address(message, signatures[i]),&#13;
            "Invalid signature for address &lt;%s&gt;".format(signer)&#13;
        );&#13;
    }&#13;
&#13;
    val evm_signers = set(signers);&#13;
&#13;
    for (signer in ft_and_evm_signers) {&#13;
        if (signer.size() == EVM_ADDRESS_SIZE) require(signer in evm_signers, "Missing signature for address &lt;%s&gt;".format(signer));&#13;
        else if (signer.size() == FT_PUBKEY_SIZE) require(op_context.is_signer(signer), "Missing signature for public key &lt;%s&gt;".format(signer));&#13;
        else require(false, "Unsupported signer &lt;%s&gt;".format(signer));&#13;
    }&#13;
}&#13;
&#13;
function get_evm_signatures(): (signers: list&lt;byte_array&gt;, signatures: list&lt;signature&gt;) {&#13;
    if (op_context.op_index == 0) return (signers = list&lt;byte_array&gt;(), signatures = list&lt;signature&gt;());&#13;
&#13;
    val tx_operations = op_context.get_all_operations();&#13;
    val prev_op = tx_operations[op_context.op_index-1];&#13;
    var evm_signatures_op: gtx_operation? = null;&#13;
    &#13;
    if (is_evm_signatures_op(prev_op)) {&#13;
        evm_signatures_op = prev_op;&#13;
    } else if (&#13;
        op_context.op_index &gt; 1 and&#13;
        (is_auth_op(prev_op) or strategies.is_strategy_op(prev_op)) and &#13;
        is_evm_signatures_op(tx_operations[op_context.op_index-2])&#13;
    ) {&#13;
        evm_signatures_op = tx_operations[op_context.op_index-2];&#13;
    }&#13;
&#13;
    if (empty(evm_signatures_op)) return (signers = list&lt;byte_array&gt;(), signatures = list&lt;signature&gt;());&#13;
&#13;
    val args = struct&lt;evm_signatures&gt;.from_gtv(evm_signatures_op.args.to_gtv());&#13;
&#13;
    require(&#13;
        args.signers.size() == args.signatures.size(),&#13;
        "Number of evm signers &lt;%d&gt; is not equal to number of evm signatures &lt;%d&gt;".format(args.signers.size(), args.signatures.size())&#13;
    );&#13;
&#13;
    var signatures = list&lt;signature&gt;();&#13;
    for (i in range(args.signatures.size())) {&#13;
        val signature = require(&#13;
            args.signatures[i],&#13;
            "Missing signature for address &lt;%s&gt;.".format(args.signers[i])&#13;
        );&#13;
        signatures.add(signature);&#13;
    }&#13;
&#13;
    return (&#13;
        signers = args.signers,&#13;
        signatures = signatures&#13;
    );&#13;
}&#13;
&#13;
function extract_account_id(auth_op: gtx_operation): byte_array {&#13;
    require(is_auth_op(auth_op), "Operation %s is not an auth operation".format(auth_op.name));&#13;
    require(auth_op.args.size() &gt;= 1, "Invalid auth op, insufficient number of args: %s".format(auth_op.args.size()));&#13;
    return byte_array.from_gtv(auth_op.args[0]);&#13;
}&#13;
&#13;
function is_auth_op(op: gtx_operation) = op.name in [EVM_AUTH_OP, FT_AUTH_OP];&#13;
&#13;
function is_evm_signatures_op(op: gtx_operation) = op.name == "ft4.evm_signatures";&#13;
&#13;
function get_auth_details_from_auth_operation() {&#13;
    if (op_context.op_index == 0) return null;&#13;
    val op = op_context.get_all_operations()[op_context.op_index-1];&#13;
    if (not is_auth_op(op)) return null;&#13;
&#13;
    return (&#13;
        account_id = byte_array.from_gtv(op.args[0]),&#13;
        auth_descriptor_id = byte_array.from_gtv(op.args[1])&#13;
    );&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/core/auth/login.rell">
                                <string>&#13;
val DEFAULT_LOGIN_CONFIG_NAME = "default";&#13;
&#13;
struct _login_config {&#13;
    flags: list&lt;text&gt;;&#13;
    rules: gtv? = null;&#13;
}&#13;
&#13;
@extendable&#13;
function login_config(): map&lt;name, _login_config&gt;;&#13;
&#13;
function add_login_config(&#13;
    name = DEFAULT_LOGIN_CONFIG_NAME,&#13;
    flags: list&lt;text&gt;,&#13;
    rules: gtv? = null&#13;
) {&#13;
    return [name: _login_config(flags, rules)];&#13;
}&#13;
&#13;
function map_rule(rule: rule_expression): gtv {&#13;
    return [&#13;
        rule.operator.name.to_gtv(),&#13;
        rule.variable.name.to_gtv(),&#13;
        rule.value.to_gtv()&#13;
    ].to_gtv();&#13;
}&#13;
&#13;
function login_simple_rule(rule: rule_expression) = map_rule(rule);&#13;
&#13;
function login_rules(rules_list: list&lt;rule_expression&gt;): gtv {&#13;
    require(rules_list.size() &gt; 0, "Empty login rules list");&#13;
&#13;
    if (rules_list.size() == 1) return map_rule(rules_list[0]);&#13;
    &#13;
    val rules = ["and".to_gtv()];&#13;
    for (rule in rules_list) {&#13;
        rules.add(map_rule(rule));&#13;
    }&#13;
    return rules.to_gtv();&#13;
}&#13;
&#13;
function ttl(millis: integer): gtv {&#13;
    return map_rule(&#13;
        rule_expression(&#13;
            rule_operator.lt,&#13;
            rule_variable.relative_block_time,&#13;
            millis&#13;
        )&#13;
    );&#13;
}&#13;
&#13;
enum rule_variable {&#13;
    block_height,&#13;
    block_time,&#13;
    op_count,&#13;
    relative_block_height,&#13;
    relative_block_time&#13;
}&#13;
&#13;
enum rule_operator {&#13;
    lt,&#13;
    le,&#13;
    eq,&#13;
    ge,&#13;
    gt&#13;
}&#13;
&#13;
struct rule_expression {&#13;
&#9;operator: rule_operator;&#13;
&#9;variable: rule_variable;&#13;
&#9;value: integer;&#13;
}&#13;
&#13;
struct rule_parameters {&#13;
&#9;variable: rule_variable;&#13;
&#9;value: integer;&#13;
}&#13;
&#13;
/*&#13;
 * Operator functions&#13;
 */&#13;
&#13;
function greater_than(rule_parameters) = rule_expression(&#13;
    rule_parameters.variable,&#13;
    rule_operator.gt,&#13;
    rule_parameters.value&#13;
);&#13;
&#13;
function greater_or_equal(rule_parameters) = rule_expression(&#13;
    rule_parameters.variable,&#13;
    rule_operator.ge,&#13;
    rule_parameters.value&#13;
);&#13;
&#13;
function equals(rule_parameters): rule_expression {&#13;
    return rule_expression(&#13;
        rule_parameters.variable,&#13;
        rule_operator.eq,&#13;
        rule_parameters.value&#13;
    );&#13;
}&#13;
&#13;
function less_than(rule_parameters) = rule_expression(&#13;
    rule_parameters.variable,&#13;
    rule_operator.lt,&#13;
    rule_parameters.value&#13;
);&#13;
&#13;
function less_or_equal(rule_parameters) = rule_expression(&#13;
    rule_parameters.variable,&#13;
    rule_operator.le,&#13;
    rule_parameters.value&#13;
);&#13;
&#13;
/*&#13;
 * Rule variable functions&#13;
 */&#13;
&#13;
function block_height(integer) = rule_parameters(&#13;
    rule_variable.block_height,&#13;
    integer&#13;
);&#13;
&#13;
function block_time(integer) = rule_parameters(&#13;
    rule_variable.block_time,&#13;
    integer&#13;
);&#13;
&#13;
function op_count(integer) = rule_parameters(&#13;
    rule_variable.op_count,&#13;
    integer&#13;
);&#13;
&#13;
function relative_block_height(integer) = rule_parameters(&#13;
    rule_variable.relative_block_height,&#13;
    integer&#13;
);&#13;
&#13;
function relative_block_time(integer) = rule_parameters(&#13;
    rule_variable.relative_block_time,&#13;
    integer&#13;
);&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/core/auth/module.rell">
                                <string>@mount('ft4')&#13;
module;&#13;
&#13;
import ^^.core.accounts;&#13;
import ^^.core.accounts.strategies;&#13;
import ^^.utils;&#13;
import ^^.version;&#13;
&#13;
import ^^.external.auth.{&#13;
    evm_signatures&#13;
};&#13;
&#13;
struct module_args {&#13;
    evm_signatures_authorized_operations: gtv? = null;&#13;
}&#13;
&#13;
struct auth_data {&#13;
    flags: list&lt;text&gt;;&#13;
    message: text;&#13;
}&#13;
&#13;
struct _auth_handler {&#13;
    flags: list&lt;text&gt;;&#13;
    message_formatter: ((gtv) -&gt; text)? = null;&#13;
    resolver: ((gtv, byte_array, list&lt;byte_array&gt;) -&gt; byte_array?)? = null;&#13;
}&#13;
&#13;
/*&#13;
 * The constant that defines app level authentication scope.&#13;
 * If scope is omitted when defining an auth handler, then&#13;
 * it has 'app' scope, i.e. it is used to authenticate &#13;
 * operations that do not have own auth handlers or if &#13;
 * there is no mount point auth handler for the operation.&#13;
 */&#13;
val APP_SCOPE = "app";&#13;
&#13;
/*&#13;
 * Extendable function used to define auth handlers. &#13;
 * When called it returns a list of all auth handlers defined&#13;
 * in the dapp.&#13;
 */&#13;
@extendable &#13;
function auth_handler(): map&lt;name, _auth_handler&gt;;&#13;
&#13;
/*&#13;
 * Finds auth handler for provided operation name.&#13;
 */&#13;
function get_auth_handler(op_name: name) {&#13;
    require_valid_scope_name(op_name);&#13;
    val auth_handlers = auth_handler();&#13;
    if (op_name in auth_handlers) return auth_handlers[op_name];&#13;
    val override_name = "__override__" + op_name;&#13;
    if (override_name in auth_handlers) return auth_handlers[override_name];&#13;
&#13;
    val handler = get_mount_scope_auth_handler(auth_handlers, op_name);&#13;
    if (handler??) return handler;&#13;
&#13;
    require(&#13;
        auth_handlers.get_or_null(APP_SCOPE),&#13;
        "Cannot find auth handler for operation &lt;%s&gt;".format(op_name)&#13;
    );&#13;
    return auth_handlers[APP_SCOPE];&#13;
}&#13;
&#13;
function add_auth_handler(&#13;
    scope: text = APP_SCOPE, &#13;
    flags: list&lt;text&gt;,&#13;
    message: ((gtv) -&gt; text)? = null,&#13;
    resolver: ((gtv, byte_array, list&lt;byte_array&gt;) -&gt; byte_array?)? = null&#13;
) = [valid_scope_name(scope): _auth_handler(flags, message, resolver)];&#13;
&#13;
function add_overridable_auth_handler(&#13;
    scope: text = APP_SCOPE,&#13;
    flags: list&lt;text&gt;,&#13;
    message: ((gtv) -&gt; text)? = null,&#13;
    resolver: ((gtv, byte_array, list&lt;byte_array&gt;) -&gt; byte_array?)? = null&#13;
) = ["__override__" + valid_scope_name(scope): _auth_handler(flags, message, resolver)];&#13;
&#13;
function valid_scope_name(scope: text) {&#13;
    val scope_name = scope.trim();&#13;
    require_valid_scope_name(scope_name);&#13;
    return scope_name;&#13;
}&#13;
&#13;
function args() = op_context.get_current_operation().args.to_gtv();&#13;
&#13;
struct signature {&#13;
    r: byte_array;&#13;
    s: byte_array;&#13;
    v: integer;&#13;
}&#13;
&#13;
struct evm_auth_args {&#13;
    accounts.account;&#13;
    accounts.account_auth_descriptor;&#13;
    signatures: list&lt;signature?&gt;;&#13;
}&#13;
&#13;
function get_mount_scope_auth_handler(auth_handlers: map&lt;name, _auth_handler&gt;, op_name: name) {&#13;
    val op_name_components = op_name.split(".");&#13;
    if (op_name_components.size() &lt; 2) return null;&#13;
    &#13;
    for (count in range(op_name_components.size()-1, 0, -1)) {&#13;
        val mount_point = join_text_list(op_name_components, count);&#13;
        if (mount_point in auth_handlers) return auth_handlers[mount_point];&#13;
    }&#13;
&#13;
    return null;&#13;
}&#13;
&#13;
/*&#13;
 * Creates message from operation name and arguments.&#13;
 * It is used when `evm_auth` is used to authenticate a user, &#13;
 * but auth message is not specified in the auth handler of the operation.&#13;
 */&#13;
function generate_operation_auth_message(blockchain_rid: byte_array, op: gtx_operation) {&#13;
    var message = "Please sign the message to call\noperation:\n- %s".format(op.name);&#13;
&#13;
    if (op.args.size() &gt; 0) {&#13;
        message = message + "\n\n";&#13;
        var arguments = "with arguments:\n";&#13;
        for (arg in op.args) {&#13;
            val argument_value = utils.convert_gtv_to_text(arg);&#13;
&#13;
            arguments = arguments + "- %s\n".format(argument_value);&#13;
        }&#13;
        message = message + arguments.sub(0, arguments.size() - 1);&#13;
    }&#13;
    &#13;
    return message;&#13;
}&#13;
&#13;
function join_text_list(components: list&lt;text&gt;, count: integer) {&#13;
    require(count &lt; components.size() and count &gt; 0, "Error building mount path");&#13;
    var result = components[0];&#13;
    for (i in range(1, count)) {&#13;
        result = result + "." + components[i];&#13;
    }&#13;
    return result;&#13;
}&#13;
&#13;
function require_valid_scope_name(name) =     &#13;
    require(&#13;
        name.matches("^\\w+(\\.\\w+)*$"), &#13;
        "Invalid scope name &lt;%s&gt;".format(name)&#13;
    );&#13;
&#13;
/*&#13;
 * Checks whether `evm_signatures` operation can be used with provided operation.&#13;
 * We don't keep track of nonce for keys used with evm_signatures, therefore if not used with care,&#13;
 * authorizing an operation with `evm_signatures` could lead to replay attack. In order to use it with&#13;
 * an operation, the operation has to be whitelisted. By default, library only allows &#13;
 * `evm_signatures` to be used with `ft4.add_auth_descriptor` and `ft4.register_account`.&#13;
 * `evm_signatures` is safe to use in combination with `ft_auth` or `evm_auth` operation.&#13;
 * However if used as only way to authorize an operation, then the operation has to ensure that it&#13;
 * cannot be called more than once with same parameters, e.g. operation creates an entity that has id&#13;
 * that is derived from operation parameters.&#13;
 */&#13;
  &#13;
function is_evm_signatures_authorized_operation(name): boolean {&#13;
    val whitelisted_operations = set([&#13;
        "ft4.register_account",&#13;
        "ft4.add_auth_descriptor",&#13;
        "ft4.update_main_auth_descriptor"&#13;
    ]);&#13;
&#13;
    if (chain_context.args.evm_signatures_authorized_operations??) {&#13;
        whitelisted_operations.add_all(require(&#13;
            try_call(set&lt;text&gt;.from_gtv(chain_context.args.evm_signatures_authorized_operations!!, *)),&#13;
            "Cannot parse 'evm_signatures_authorized_operations' config parameter"&#13;
        ));&#13;
    }&#13;
&#13;
    return name in whitelisted_operations;&#13;
}&#13;
&#13;
function require_evm_signatures_can_be_used() {&#13;
    val all_operations = op_context.get_all_operations();&#13;
&#13;
    require(&#13;
        all_operations.size() &gt; op_context.op_index+1,&#13;
        "Cannot find an operation to authorize with 'ft4.evm_signatures'"&#13;
    );&#13;
    var next_op = all_operations[op_context.op_index+1];&#13;
&#13;
    var op_to_authorize: gtx_operation?;&#13;
    if (not (is_auth_op(next_op) or strategies.is_strategy_op(next_op))) {&#13;
        op_to_authorize = next_op;&#13;
    } else {&#13;
        require(&#13;
            all_operations.size() &gt; op_context.op_index+2,&#13;
            "Cannot find an operation to authorize with 'ft4.evm_signatures'"&#13;
        );&#13;
        op_to_authorize = all_operations[op_context.op_index+2];&#13;
    }&#13;
&#13;
    require(&#13;
        is_evm_signatures_authorized_operation(op_to_authorize.name),&#13;
        "Cannot authorize operation &lt;%s&gt; with evm_signatures".format(op_to_authorize.name)&#13;
    );&#13;
}&#13;
&#13;
function require_regular_next_operation() {&#13;
    val all_operations = op_context.get_all_operations();&#13;
    val this_op = op_context.get_all_operations()[op_context.op_index];&#13;
    &#13;
    require(&#13;
        all_operations.size() &gt; op_context.op_index + 1,&#13;
        "&lt;%s&gt; must be followed by an operation to authorize".format(this_op.name)&#13;
    );&#13;
    &#13;
    val next_op = all_operations[op_context.op_index + 1];&#13;
    val prohibited_operations = ["nop", "timeb", "iccf_proof", "ft4.ft_auth", "ft4.evm_auth", "ft4.evm_signatures"];&#13;
    require(not prohibited_operations.contains(next_op.name), "&lt;%s&gt; cannot authorize &lt;%s&gt;".format(this_op.name, next_op.name));&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/external/accounts/module.rell">
                                <string>@mount('ft4')&#13;
module;&#13;
&#13;
import ^^.core.accounts;&#13;
import ^^.core.auth;&#13;
import ^^.utils;&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/external/accounts/operations.rell">
                                <string>&#13;
function delete_auth_descriptor_message(gtv) {&#13;
    val params = struct&lt;delete_auth_descriptor&gt;.from_gtv(gtv);&#13;
    return "Please sign the message\nto delete auth descriptor:\n%s\n\nfrom account\n{account_id}".format(params.auth_descriptor_id);&#13;
}&#13;
&#13;
function delete_auth_descriptor_resolver(args: gtv, account_id: byte_array, auth_descriptor_ids: list&lt;byte_array&gt;) {&#13;
    val params = struct&lt;delete_auth_descriptor&gt;.from_gtv(args);&#13;
    if (params.auth_descriptor_id in auth_descriptor_ids) return params.auth_descriptor_id;&#13;
&#13;
    for (ad in accounts.account_auth_descriptor @* { .account.id == account_id, .id in auth_descriptor_ids }) {&#13;
        if (accounts.has_flags(ad, ["A"])) return ad.id;&#13;
    }&#13;
&#13;
    return null;&#13;
}&#13;
&#13;
@extend(auth.auth_handler)&#13;
function () = auth.add_overridable_auth_handler(&#13;
    scope = rell.meta(delete_auth_descriptor).mount_name,&#13;
    flags = [],&#13;
    message = delete_auth_descriptor_message(*),&#13;
    resolver = delete_auth_descriptor_resolver(*)&#13;
);&#13;
&#13;
operation delete_auth_descriptor(auth_descriptor_id: byte_array) {&#13;
    val account = auth.authenticate();&#13;
    accounts.delete_auth_descriptor(&#13;
        accounts.auth_descriptor_by_id(account, auth_descriptor_id)&#13;
    );&#13;
}&#13;
&#13;
function delete_auth_descriptors_for_signer_message(gtv) {&#13;
    val params = struct&lt;delete_auth_descriptors_for_signer&gt;.from_gtv(gtv);&#13;
    return "Please sign the message\nto delete all auth descriptor for signer:\n%s\n\nfrom account\n{account_id}".format(params.signer);&#13;
}&#13;
&#13;
function delete_auth_descriptors_for_signer_resolver(args: gtv, account_id: byte_array, auth_descriptor_ids: list&lt;byte_array&gt;) {&#13;
    val params = struct&lt;delete_auth_descriptors_for_signer&gt;.from_gtv(args);&#13;
&#13;
    val ads = (a_ad: accounts.account_auth_descriptor, ad_s: accounts.auth_descriptor_signer) @* {&#13;
        a_ad.account.id == account_id,&#13;
        ad_s.account_auth_descriptor == a_ad,&#13;
        ad_s.id == params.signer,&#13;
        a_ad.auth_type == accounts.auth_type.S,&#13;
        a_ad.id in auth_descriptor_ids&#13;
    } (a_ad.id);&#13;
    if (not ads.empty()) {&#13;
        return ads[0];&#13;
    }&#13;
&#13;
    for (ad in accounts.account_auth_descriptor @* { .account.id == account_id, .id in auth_descriptor_ids }) {&#13;
        if (accounts.has_flags(ad, ["A"])) return ad.id;&#13;
    }&#13;
&#13;
    return null;&#13;
}&#13;
&#13;
@extend(auth.auth_handler)&#13;
function () = auth.add_overridable_auth_handler(&#13;
    scope = rell.meta(delete_auth_descriptors_for_signer).mount_name,&#13;
    flags = [],&#13;
    message = delete_auth_descriptors_for_signer_message(*),&#13;
    resolver = delete_auth_descriptors_for_signer_resolver(*)&#13;
);&#13;
&#13;
operation delete_auth_descriptors_for_signer(signer: byte_array) {&#13;
    val account = auth.authenticate();&#13;
&#13;
    val ads = (a_ad: accounts.account_auth_descriptor, ad_s: accounts.auth_descriptor_signer) @* {&#13;
        a_ad.account == account,&#13;
        ad_s.account_auth_descriptor == a_ad,&#13;
        ad_s.id == signer&#13;
    } (a_ad);&#13;
    for (ad in ads) {&#13;
        accounts.delete_auth_descriptor(ad);&#13;
    }&#13;
}&#13;
&#13;
function delete_all_auth_descriptors_except_main_message(gtv) {&#13;
    return "Please sign the message\nto delete all auth descriptors except main\nfrom account:\n{account_id}";&#13;
}&#13;
&#13;
function delete_all_auth_descriptors_except_main_resolver(args: gtv, account_id: byte_array, auth_descriptor_ids: list&lt;byte_array&gt;) {&#13;
    val main_auth_descriptor = require(&#13;
        accounts.main_auth_descriptor @? { .account.id == account_id } .auth_descriptor,&#13;
        "Account &lt;%s&gt; does not have main auth descriptor set".format(account_id)&#13;
    );&#13;
&#13;
    return if (main_auth_descriptor.id in auth_descriptor_ids) main_auth_descriptor.id else null;&#13;
}&#13;
&#13;
@extend(auth.auth_handler)&#13;
function () = auth.add_overridable_auth_handler(&#13;
    scope = rell.meta(delete_all_auth_descriptors_except_main).mount_name,&#13;
    flags = ["A"],&#13;
    message = delete_all_auth_descriptors_except_main_message(*),&#13;
    resolver = delete_all_auth_descriptors_except_main_resolver(*)&#13;
);&#13;
&#13;
operation delete_all_auth_descriptors_except_main() {&#13;
    val account = auth.authenticate();&#13;
    accounts.delete_all_auth_descriptors_except_main(account);&#13;
}&#13;
&#13;
function add_auth_descriptor_message(gtv) {&#13;
    val params = struct&lt;add_auth_descriptor&gt;.from_gtv(gtv);&#13;
    val flags = params.new_desc.args[0];&#13;
&#13;
    return "Please sign the message\nto add auth descriptor\nwith flags:\n%s\n\nto account:\n{account_id}".format(flags);&#13;
}&#13;
&#13;
@extend(auth.auth_handler)&#13;
function () = auth.add_overridable_auth_handler(&#13;
    scope = rell.meta(add_auth_descriptor).mount_name,&#13;
    flags = ["A"],&#13;
    message = add_auth_descriptor_message(*)&#13;
);&#13;
&#13;
operation add_auth_descriptor(new_desc: accounts.auth_descriptor) {&#13;
    val account = auth.authenticate();&#13;
    val signers = accounts.get_signers(new_desc);&#13;
    auth.verify_signers(signers);&#13;
    accounts.add_auth_descriptor(account, new_desc);&#13;
}&#13;
&#13;
function update_main_auth_descriptor_message(gtv) {&#13;
    val params = struct&lt;update_main_auth_descriptor&gt;.from_gtv(gtv);&#13;
    val flags = params.new_desc.args[0];&#13;
    val signers = accounts.get_signers(params.new_desc);&#13;
&#13;
    return "Please sign the message to\nset new main auth descriptor\n\nwith flags:\n%s\n\nand signers:\n%s\n\nof account:\n{account_id}".format(flags, signers);&#13;
}&#13;
&#13;
function update_main_auth_descriptor_resolver(args: gtv, account_id: byte_array, auth_descriptor_ids: list&lt;byte_array&gt;) {&#13;
    val main_auth_descriptor = require(&#13;
        accounts.main_auth_descriptor @? { .account.id == account_id } .auth_descriptor,&#13;
        "Account &lt;%s&gt; does not have main auth descriptor set".format(account_id)&#13;
    );&#13;
&#13;
    return if (main_auth_descriptor.id in auth_descriptor_ids) main_auth_descriptor.id else null;&#13;
}&#13;
&#13;
@extend(auth.auth_handler)&#13;
function () = auth.add_overridable_auth_handler(&#13;
    scope = rell.meta(update_main_auth_descriptor).mount_name,&#13;
    flags = ["A"],&#13;
    message = update_main_auth_descriptor_message(*),&#13;
    resolver = update_main_auth_descriptor_resolver(*)&#13;
);&#13;
&#13;
operation update_main_auth_descriptor(new_desc: accounts.auth_descriptor) {&#13;
    val account = auth.authenticate();&#13;
    auth.verify_signers(accounts.get_signers(new_desc));&#13;
    accounts.update_main_auth_descriptor(account, new_desc);&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/external/accounts/queries.rell">
                                <string>&#13;
query get_config() {&#13;
    return (&#13;
        rate_limit = accounts.get_rate_limit_config(),&#13;
        auth_descriptor = accounts.get_auth_descriptor_config()&#13;
    );&#13;
}&#13;
&#13;
query get_account_rate_limit_last_update(account_id: byte_array) {&#13;
    val account = accounts.Account(account_id);&#13;
    if (accounts.get_rate_limit_config_for_account(account).active == false) return (points = 0, last_update = 0);&#13;
    &#13;
    return accounts.rl_state @ { account }&#13;
    (&#13;
        .points, &#13;
        .last_update&#13;
    );&#13;
}&#13;
&#13;
query is_auth_descriptor_valid(account_id: byte_array, auth_descriptor_id: byte_array) {&#13;
    return not accounts.have_violating_rules(accounts.account_auth_descriptor @ {&#13;
        .account.id == account_id,&#13;
        .id == auth_descriptor_id&#13;
    });&#13;
}&#13;
&#13;
query get_account_auth_descriptors(id: byte_array) {&#13;
    return accounts.get_auth_descriptors(id);&#13;
}&#13;
&#13;
query get_account_auth_descriptors_by_signer(account_id: byte_array, signer: byte_array) {&#13;
    return accounts.get_auth_descriptors_by_signer(account_id, signer);&#13;
}&#13;
&#13;
query get_account_auth_descriptor_by_id(account_id: byte_array, id: byte_array) {&#13;
    return accounts.account_auth_descriptor @ {&#13;
        .id == id,&#13;
        .account.id == account_id&#13;
    } ( accounts.get_auth_descriptor_data($.to_struct()) );&#13;
}&#13;
&#13;
query get_account_main_auth_descriptor(account_id: byte_array) {&#13;
    return accounts.main_auth_descriptor @ {&#13;
        .account.id == account_id&#13;
    } ( accounts.get_auth_descriptor_data(.auth_descriptor.to_struct()) );&#13;
}&#13;
&#13;
query get_account_by_id(id: byte_array) {&#13;
    return accounts.account @? { id } ( .id );&#13;
}&#13;
&#13;
query get_accounts_by_signer(id: byte_array, page_size: integer?, page_cursor: text?) {&#13;
    return utils.make_page(&#13;
        accounts.get_paginated_accounts_by_signer(id, page_size, page_cursor),&#13;
        page_size&#13;
    );&#13;
}&#13;
&#13;
query get_accounts_by_auth_descriptor_id(id: byte_array, page_size: integer?, page_cursor: text?) {&#13;
    return utils.make_page(&#13;
        accounts.get_paginated_accounts_by_ad_id(id, page_size, page_cursor),&#13;
        page_size&#13;
    );&#13;
}&#13;
&#13;
query get_accounts_by_type(type: text, page_size: integer, page_cursor: text?) {&#13;
    return utils.make_page(&#13;
        accounts.get_paginated_accounts_by_type(type, page_size, page_cursor),&#13;
        page_size&#13;
    );&#13;
}&#13;
&#13;
query get_auth_descriptor_counter(&#13;
    account_id: byte_array, &#13;
    auth_descriptor_id: byte_array&#13;
) = accounts.account_auth_descriptor @? { &#13;
        .account.id == account_id, &#13;
        .id == auth_descriptor_id &#13;
    } ( .ctr );&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/external/accounts/strategies/module.rell">
                                <string>@mount('ft4')&#13;
module;&#13;
&#13;
import ^^^.core.accounts.strategies;&#13;
import ^^^.core.accounts;&#13;
import ^^^.auth;&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/external/accounts/strategies/operations.rell">
                                <string>operation register_account() {&#13;
    strategies.register_account();&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/external/accounts/strategies/queries.rell">
                                <string>query get_register_account_message(&#13;
    strategy_operation: gtx_operation,&#13;
    register_account_operation: gtx_operation&#13;
) = strategies.get_register_account_message(strategy_operation, register_account_operation);&#13;
&#13;
query get_enabled_registration_strategies(): set&lt;text&gt; = strategies.strategy().keys();&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/external/auth/module.rell">
                                <string>@mount('ft4')&#13;
module;&#13;
&#13;
import ^^.core.auth;&#13;
import ^^.utils;&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/external/auth/operations.rell">
                                <string>&#13;
operation evm_auth(&#13;
    account_id: byte_array,&#13;
    auth_descriptor_id: byte_array,&#13;
    signatures: list&lt;auth.signature?&gt;&#13;
) {&#13;
    auth.require_regular_next_operation();&#13;
}&#13;
&#13;
operation evm_signatures(&#13;
    signers: list&lt;byte_array&gt;, &#13;
    signatures: list&lt;auth.signature?&gt;&#13;
) {&#13;
    auth.require_evm_signatures_can_be_used();&#13;
}&#13;
&#13;
operation ft_auth(&#13;
    account_id: byte_array,&#13;
    auth_descriptor_id: byte_array&#13;
) {&#13;
    auth.require_regular_next_operation();&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/external/auth/queries.rell">
                                <string>struct _auth_handler_client {&#13;
    name: text;&#13;
    flags: list&lt;text&gt;;&#13;
    dynamic: boolean;&#13;
}&#13;
&#13;
query get_auth_flags(op_name: name) = auth.get_auth_handler(op_name).flags;&#13;
&#13;
query get_auth_message_template(op_name: name, op_args: gtv?) = auth.get_auth_message_template(op_name, op_args);&#13;
&#13;
query get_login_config(name? = null) {&#13;
    val configs = auth.login_config();&#13;
    val config_name = name ?: auth.DEFAULT_LOGIN_CONFIG_NAME;&#13;
&#13;
    if (config_name == auth.DEFAULT_LOGIN_CONFIG_NAME) {&#13;
        return if (config_name in configs)&#13;
            configs[config_name]&#13;
        else&#13;
            auth._login_config(&#13;
                flags = [],&#13;
                rules = auth.ttl(1 * utils.MILLISECONDS_PER_DAY)&#13;
            );&#13;
    }&#13;
    &#13;
    return require(&#13;
        configs.get_or_null(config_name), &#13;
        "Unknown login configuration &lt;%s&gt;".format(config_name)&#13;
    );&#13;
}&#13;
&#13;
query get_auth_handler_for_operation(op_name: name) {&#13;
  val handler = auth.get_auth_handler(op_name);&#13;
  return _auth_handler_client(&#13;
    name=op_name,&#13;
    flags=handler.flags,&#13;
    dynamic=handler.resolver != null&#13;
  );&#13;
}&#13;
&#13;
query get_first_allowed_auth_descriptor_by_signers(&#13;
  op_name: name,&#13;
  args: gtv,&#13;
  account_id: byte_array,&#13;
  signers: list&lt;byte_array&gt;&#13;
): byte_array? = auth.get_first_allowed_auth_descriptor_by_signers(op_name, args, account_id, signers);&#13;
&#13;
query get_first_allowed_auth_descriptor(&#13;
  op_name: name,&#13;
  args: gtv,&#13;
  account_id: byte_array,&#13;
  ad_ids: list&lt;byte_array&gt;&#13;
): byte_array? = auth.get_first_allowed_auth_descriptor(op_name, args, account_id, ad_ids);&#13;
&#13;
query get_all_auth_handlers() {&#13;
  val auth_handlers = auth.auth_handler();&#13;
  return auth_handlers @* {}(&#13;
    _auth_handler_client(&#13;
      name=$[0],&#13;
      flags=$[1].flags,&#13;
      dynamic=$[1].resolver != null&#13;
    )&#13;
  );&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/module.rell">
                                <string>struct module_args {&#13;
    query_max_page_size: integer = 100;&#13;
}&#13;
&#13;
function get_module_args() {&#13;
    return chain_context.args;&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/utils/pagination.rell">
                                <string>import ^.{ get_module_args };&#13;
&#13;
struct page_cursor {&#13;
    before_rowid: rowid? = null;&#13;
}&#13;
&#13;
struct pagination_result {&#13;
    data: gtv;&#13;
    rowid: rowid;&#13;
}&#13;
&#13;
function encode_cursor(page_cursor) = page_cursor.to_bytes().to_base64();&#13;
&#13;
function decode_cursor(cursor: text) = page_cursor.from_bytes(byte_array.from_base64(cursor));&#13;
&#13;
struct paged_result {&#13;
    next_cursor: text?;&#13;
    data: list&lt;gtv&gt;;&#13;
}&#13;
&#13;
function null_page() = paged_result(&#13;
    next_cursor = null,&#13;
    data = list&lt;gtv&gt;()&#13;
);&#13;
&#13;
function fetch_data_size(page_size: integer? = get_module_args().query_max_page_size) = &#13;
    min(get_module_args().query_max_page_size, page_size ?: get_module_args().query_max_page_size) + 1;&#13;
&#13;
function before_rowid(page_cursor: text?) {&#13;
    var before_rowid: rowid? = null;&#13;
    if (page_cursor??) {&#13;
        val cursor = decode_cursor(page_cursor);&#13;
        before_rowid = cursor.before_rowid;&#13;
    }&#13;
    return before_rowid;&#13;
}&#13;
&#13;
&#13;
function make_page(pagination_results: list&lt;pagination_result&gt;, page_size: integer?): paged_result {&#13;
    if (page_size != null) {&#13;
        require(page_size &gt; 0, "Must return at least one item");&#13;
    }&#13;
    if (empty(pagination_results)) {&#13;
         return null_page();&#13;
    }&#13;
    // adding +1 should help with next page null situation when current page size&#13;
    // is equal to max page size&#13;
    if(pagination_results.size() &lt; fetch_data_size(page_size)) {&#13;
        return paged_result(&#13;
            next_cursor = null,&#13;
            data = pagination_results  @* {} .data&#13;
        );&#13;
    }&#13;
    val paginated_result = pagination_results.sub(0, pagination_results.size()-1);&#13;
    val next_id = pagination_results[pagination_results.size()-2].rowid;&#13;
    val next_cursor = page_cursor(&#13;
        next_id&#13;
    );&#13;
    return paged_result(&#13;
        next_cursor = encode_cursor(next_cursor),&#13;
        data = paginated_result  @* {} .data&#13;
    );&#13;
}&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/utils/utils.rell">
                                <string>val MILLISECONDS_PER_DAY = 24 * 60 * 60 * 1000;&#13;
&#13;
/*&#13;
 * For complex validation we might not want to use simple "require()"&#13;
 * but an error message that is returned. &#13;
 */&#13;
struct validation_result {&#13;
    valid: boolean;&#13;
    error: text? = null;&#13;
}&#13;
&#13;
val VALID = validation_result(true, null);&#13;
&#13;
function invalid(error: text) = validation_result(false, error);&#13;
&#13;
function make_auth_message(message: text) {&#13;
    return "Blockchain:\n{blockchain_rid}\n\n" + message + "\n\nNonce: {nonce}";&#13;
}&#13;
&#13;
function derive_nonce(op: gtx_operation, nonce: integer) {&#13;
    return (&#13;
        chain_context.blockchain_rid, &#13;
        op.name, &#13;
        op.args, &#13;
        nonce&#13;
    ).hash().to_hex().upper_case();&#13;
}&#13;
&#13;
function latest_time() =&#13;
    if (op_context.exists and op_context.block_height &gt; 0)&#13;
        op_context.last_block_time&#13;
    else&#13;
        block @ {} (@max .timestamp) ?: 0;&#13;
&#13;
function validate_blockchain_rid(blockchain_rid: byte_array, descriptor: text = "blockchain_rid") {&#13;
    require(blockchain_rid.size() &gt; 0, "%s cannot be empty".format(descriptor));&#13;
    require(&#13;
        blockchain_rid.size() == 32, &#13;
        "%s &lt;%s&gt; has invalid length. Expected &lt;32&gt; bytes, found &lt;%d&gt;.".format(descriptor, blockchain_rid, blockchain_rid.size())&#13;
    );&#13;
}&#13;
&#13;
/**&#13;
 * Converts a gtv value to a pretty text representation, with newlines and indentations.&#13;
 *&#13;
 * @param gtv                   the gtv value to convert.&#13;
 *&#13;
 * @param indentation_index     how many collections deep we are. Used for recursive&#13;
 *                              iteration on collections&#13;
 *&#13;
 * @param in_dict               if inside a dictionary, it will not add indent output&#13;
 *                              except collections. This prevents dicts having `\t`&#13;
 *                              between key and value.&#13;
 */&#13;
function convert_gtv_to_text(&#13;
    gtv,&#13;
    indentation_index: integer = 0,&#13;
    in_dict: boolean = false&#13;
): text {&#13;
    var indents = "\t".repeat(indentation_index);&#13;
    var string: text = if (in_dict) "" else indents;&#13;
    /*&#13;
     * supported types&#13;
     * - text&#13;
     * - byte_array&#13;
     * - dictionary&#13;
     * - list&#13;
     * - integer&#13;
     * - decimal&#13;
     * - big_integer&#13;
     * - boolean&#13;
     */&#13;
    if (is_text(gtv)){&#13;
        string += text.from_gtv(gtv);&#13;
    }&#13;
    else if (is_byte_array(gtv)){&#13;
        string += byte_array.from_gtv(gtv).to_hex().upper_case();&#13;
    }&#13;
    else if (is_dict(gtv)) {&#13;
        val dict = map&lt;text, gtv&gt;.from_gtv(gtv);&#13;
        if (dict.size() == 0) {&#13;
            string += "{ }";&#13;
        } else {&#13;
            string += "{\n";&#13;
            for (elm in dict) {&#13;
                string += indents + "\t" +&#13;
                    elm[0] + ": " +&#13;
                    convert_gtv_to_text(elm[1], indentation_index + 1, true) + ",\n";&#13;
            }&#13;
            string = &#13;
                // remove trailing comma and newline&#13;
                string.sub(0, string.size()-2) +&#13;
                //add newline back&#13;
                "\n" +&#13;
                // add indents or, if base level, add two spaces to match the &#13;
                // `- `(dash+space) at the start of the line&#13;
                (if (indentation_index != 0) indents else "  ") + &#13;
                //close the dict&#13;
                "}";&#13;
        }&#13;
    }&#13;
    else if (is_list(gtv)) {&#13;
        val l = list&lt;gtv&gt;.from_gtv(gtv);&#13;
        if (l.size() == 0) {&#13;
            string += "[ ]";&#13;
        } else {&#13;
            string += "[\n";&#13;
            for (elm in l) {&#13;
                string += convert_gtv_to_text(elm, indentation_index + 1) + ",\n";&#13;
            }&#13;
            string =&#13;
                // remove trailing comma and newline&#13;
                string.sub(0, string.size()-2) +&#13;
                //add newline back&#13;
                "\n" +&#13;
                // add indents or, if base level, add two spaces to match the&#13;
                // `- `(dash+space) at the start of the line&#13;
                (if (indentation_index != 0) indents else "  ") + &#13;
                //close the list&#13;
                "]";&#13;
        }&#13;
    }&#13;
    // integer, decimal, big_integer, boolean&#13;
    else {&#13;
        string += gtv;&#13;
    }&#13;
    return string;&#13;
}&#13;
&#13;
/*&#13;
 * Following list of functions are used to check type of object wrapped inside gtv (gtv is Chromia's ASN.1 based encoding).&#13;
 * See below for how encoding is defined for different types:&#13;
 * https://bitbucket.org/chromawallet/postchain-client/src/430bc34bf945905e4883af317f16bbb277102175/src/gtv/definition.ts#lines-8&#13;
 * Depending on wrapped value type, first byte of serialized gtv will have one of following values:&#13;
 * - byte_array  -&gt; x"a1" (161)&#13;
 * - text        -&gt; x"a2" (162)&#13;
 * - integer     -&gt; x"a3" (163)&#13;
 * - dict (map)  -&gt; x"a4" (164)&#13;
 * - list        -&gt; x"a5" (165)&#13;
 * - big_integer -&gt; x"a6" (166)&#13;
 *&#13;
 * In the future these functions will be replaced with native Rell functions.&#13;
 */ &#13;
&#13;
function is_byte_array(gtv) = gtv.to_bytes()[0] == 161;&#13;
&#13;
function is_text(gtv) = gtv.to_bytes()[0] == 162;&#13;
&#13;
function is_integer(gtv) = gtv.to_bytes()[0] == 163;&#13;
&#13;
function is_dict(gtv) = gtv.to_bytes()[0] == 164;&#13;
&#13;
function is_list(gtv) = gtv.to_bytes()[0] == 165;&#13;
&#13;
function is_big_integer(gtv) = gtv.to_bytes()[0] == 166;&#13;
</string>
                            </entry>
                            <entry key="lib/ft4/version.rell">
                                <string>@mount('ft4')&#13;
module;&#13;
&#13;
query get_version(): text = "1.0.0";&#13;
</string>
                            </entry>
                            <entry key="main.rell">
                                <string>module;

import to_do.*;
import registration.*;

query list_accounts() = account @* { } ( $.to_struct() );
</string>
                            </entry>
                            <entry key="registration/module.rell">
                                <string>module;&#13;
&#13;
import ^.to_do.*;&#13;
import lib.ft4.accounts.strategies.open;&#13;
import lib.ft4.accounts.strategies.{ register_account };&#13;
&#13;
operation register_user(name) {&#13;
    val account = register_account();&#13;
    val user = create user ( name, account.id, account );&#13;
}&#13;
</string>
                            </entry>
                            <entry key="to_do/auth.rell">
                                <string>@extend(auth.auth_handler)&#13;
function () = auth.add_auth_handler(&#13;
    flags = ["MySession"]&#13;
);&#13;
</string>
                            </entry>
                            <entry key="to_do/dto.rell">
                                <string>struct task_dto {&#13;
    task_id: byte_array;&#13;
    task_title: text;&#13;
    task_description: text;&#13;
    is_completed: boolean;&#13;
    due_date: integer;&#13;
    created_at: timestamp; // or created_at depending on how the task is timestamped&#13;
    updated_at: timestamp;&#13;
}&#13;
</string>
                            </entry>
                            <entry key="to_do/model.rell">
                                <string>entity user {&#13;
    key user_id: byte_array;&#13;
    mutable name: text;&#13;
    key account;&#13;
}&#13;
&#13;
entity task {&#13;
    index user;&#13;
    index task_id: byte_array;&#13;
    mutable task_title: text;&#13;
    mutable task_description: text;&#13;
    key task_title, task_description;&#13;
    mutable is_completed: boolean = false; // Status of the task&#13;
    created_at: timestamp = op_context.last_block_time;&#13;
    mutable updated_at: timestamp = op_context.last_block_time;&#13;
    mutable due_date: integer;&#13;
}&#13;
</string>
                            </entry>
                            <entry key="to_do/module.rell">
                                <string>module;&#13;
&#13;
import lib.ft4.accounts.{ account };&#13;
import lib.ft4.auth;&#13;
&#13;
function require_task(&#13;
    task_id: byte_array&#13;
) = require(&#13;
    task @? {&#13;
        task_id&#13;
    },&#13;
    "task with id %s is not in your to-do-list"&#13;
        .format(&#13;
            task_id&#13;
        )&#13;
);&#13;
</string>
                            </entry>
                            <entry key="to_do/operations.rell">
                                <string>operation create_task(&#13;
    user_id: byte_array,&#13;
    task_id: byte_array,&#13;
    task_title: text,&#13;
    task_description: text,&#13;
    due_date: integer&#13;
) {&#13;
&#13;
    val account = auth.authenticate();&#13;
    val date = due_date * 86400;&#13;
    create task (&#13;
        user @ { user_id },&#13;
        .task_id = task_id,&#13;
        .task_title = task_title,&#13;
        .task_description = task_description,&#13;
        .due_date = date&#13;
    );&#13;
}&#13;
&#13;
operation update_task(&#13;
    task_id: byte_array,&#13;
    task_title: text,&#13;
    task_description: text,&#13;
    due_date: integer&#13;
) {&#13;
    val account = auth.authenticate();&#13;
    update task @ {&#13;
        task_id&#13;
    } (&#13;
        .task_title = task_title,&#13;
        .task_description = task_description,&#13;
        .due_date = due_date,&#13;
        .updated_at&#13;
    );&#13;
}&#13;
&#13;
operation delete_task(task_id: byte_array) {&#13;
    val account = auth.authenticate();&#13;
    delete task @? { task_id };&#13;
}&#13;
&#13;
operation complete_task(task_id: byte_array) {&#13;
    val account = auth.authenticate();&#13;
    update task @ { task_id } (&#13;
        .is_completed = true,&#13;
        .updated_at&#13;
    );&#13;
}&#13;
</string>
                            </entry>
                            <entry key="to_do/queries.rell">
                                <string>// ferching all the tasks that are both completed and incompleted &#13;
&#13;
query get_user_tasks(task_id: byte_array) {&#13;
    val account = auth.authenticate();&#13;
    return task @* { task_id } (&#13;
        @sort_desc @omit task.due_date,&#13;
        task_dto (&#13;
            .task_id,&#13;
            .task_title,&#13;
            .task_description,&#13;
            .due_date,&#13;
            .is_completed,&#13;
            .created_at,&#13;
            .updated_at&#13;
        )&#13;
    );&#13;
}&#13;
&#13;
//geting all the completed tasks by descending order&#13;
&#13;
query get_user_tasks_by_status(task_id: byte_array, is_completed: boolean) {&#13;
    val account = auth.authenticate();&#13;
    return task @* {&#13;
        .task_id == task_id,&#13;
        .is_completed == is_completed&#13;
    } (&#13;
        @sort_desc task.due_date,&#13;
        .task_id,&#13;
        .task_title,&#13;
        .task_description,&#13;
        .is_completed,&#13;
        .created_at,&#13;
        .updated_at&#13;
    );&#13;
}&#13;
</string>
                            </entry>
                        </dict>
                    </entry>
                    <entry key="strictGtvConversion">
                        <int>1</int>
                    </entry>
                    <entry key="version">
                        <string>0.13.14</string>
                    </entry>
                </dict>
            </entry>
        </dict>
    </entry>
    <entry key="revolt">
        <dict>
            <entry key="fast_revolt_status_timeout">
                <int>2000</int>
            </entry>
            <entry key="revolt_when_should_build_block">
                <int>1</int>
            </entry>
        </dict>
    </entry>
</dict>
